# 14 보안 HTTP

## 1.HTTP를 안전하게 만들기

- 인증과 메세지 무결성 →  쓸만하지만, 보안 자료 접근을 위해서는 충분히 강력하지 않음
- 중요한 트랜잭셔을 위해서는 HTTP와 디지털 암호화기술을 결합해야
- 보안기술
    - 서버인증: 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
    - 클라이언트 인증: 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야 한다.
    - 무결성: 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야한다.
    - 암호화: 클라이언트와 서버는 도청 걱정 없이 서로 대화할 수 있어야 한다.
    - 효율:저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
    - 편재성: 프로토콜은 거의 모든 클라이언트와 서버에 지원되어야 한다.
    - 관리자 확장성: 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
    - 적응성: 현재 알려진 최선의 보안 방법을 지원해야한다.
    - 사회적 생존성: 사회의 문화적, 정치적 요구 만족시켜야

### 1-1. HTTPS

- HTTP를 안전하게 만드는 방식 중에 가장 인기 있는 것
- HTTPS는 HTTP 하부에 전송 레벨 암호 보안계층을 제공함으로써 동작
    - 보안계층은 안전소켓계층(SSL) 혹은 그를 계승한 전송계층보안(TLS)을 이용하여 구현된다.
    - 어려운 인코딩 및 디코딩 작업은 대부분 SSL라이브러리에서 일어난다.
    - 대부분의 경우 TCP입력/출력 호출을 SSL호출로 대체하고 보안 정보를 설정하고 관리하기 위한 몇가지 호출만 추가해주면 된다.
    

## 2. 디지털 암호화

### 🍊 들어가기전에 단어정리

- 암호
    - 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키
    - 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호화 체계
    - 인코딩과 디코딩에 **같은 키** 사용하는 알고리즘
- 비대칭키 암호화 체계
    - 인코딩과 디코딩에 **다른 키**를 사용하는 알고리즘
- 공개키 암호법
    - 비밀 메세지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명
    - 메시지가 위조 혹은 변조 되지 않았음을 입증하는 체크섬
- 디지털 인증서
    - 신뢰할 만한 조직에 의해 서명되고 검증된 신원확인 정보

### 2-1. 암호

- 메세지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀메세지를 디코딩하는 방법
- 인코딩 되기 전 원본메세지를 평문이라고 함
- 암호가 적용되어 코딩된 메세지를 암호문이라고 함

### 2-2. 키가 있는 암호

- 기계가 다른 사람의 손에 들어갈 수 있기에 대부분의 기계들에는 암호의 동작방식을 변경할 수 있는 큰 숫자로된 다른 값을 설정할 수 있는 다이얼이 달려있다.
- 누군가 기계를 훔치더라도 키 값 없이는 디코더가 동작X
- 암호 매개변수를 키라고 부름

## 3. 대칭키 암호법

- 많은 디지털 암호 알고리즘은 대칭키 암호라고 불림
- 그들이 인코딩 할 때 사용하는 키가 디코딩할 때와 같기 때문
- 대칭키 암호에서는 발송자와 수신자 모두 통신을 위해 비밀키 k를 똑같이 공유할 필요가 있다.
- 발송자
    - 공유된 비밀키를 메세지를 암호화하고 그 결과인 암호문을 수신자에게 발송하기 위해 사용
- 수신자
    - 암호문을 받은 뒤 같은 공유된 키를 사용하여 원래의 평문을 복원하기 위해 해독 함수 적용
- DES,Triple-DES,RC2,RC4

### 3-1. 키 길이와 열거 공격

- 좋은 암호 알고리즘 : 우주에 존재하는 모든 가능한 키 값을 시도하게 만드는 것
    - 무차별로 모든 키 값 대입하는 공격 : 열거공격
- 길이
    - 평범한 대칭키 암호에서 40비트 키는 작고 중요하지 않은 업무에는 충분 → 오늘날 빠른 워크 스테이션에서는 쉽게 깨질 수 있음
    - 128비트 키 : 매우 강력 , 미국 국가안보국은 긴 키를 사용하는 암호화 소프트웨어의 수출을 통제할 정도로 키의 길이는 매우 중요함!
    - 아무튼 128비트키 쨩!

### 3-2. 공유키 발급하기

- 대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 함
- n개의 노드가 있고 각 노드가 상대 n-1과 은밀하게 대화를 나누어야 한다면 n^2개의 비밀키 필요함.
- **대칭키가 훨씬 통신속도가 빠름**
    - **비대칭키로 보안적으로 커넥션을 하고 난 후 그 이후부터는 대칭키로 속도 확보**

## 4. 공개키 암호법 (비대칭키 암호)

🍊 **들어가기 전에 간단 개념정리**

- 공개키 & 개인키로 나뉨
    - 개인키,공개키와 인코딩키,디코딩키를 나눠서 봐라
    - 이건 문을 여는 열쇠에여, 이건 문을 잠그는 열쇠에여ㅋㅋㅋ 라고 한정하지 말 것
- 예시([https://www.youtube.com/watch?v=H6lpFRpyl14](https://www.youtube.com/watch?v=H6lpFRpyl14))
    - 네이버 서버가 개인키 하나를 두고 공개키를 뿌림
- 사용자는 공개키로 암호화해서 비밀번호를 보냄
    - 이 비밀번호를 복호화할 수 있는건 네이버의 개인키뿐
    - 여기서 공개키는 인코딩키, 개인키는 디코딩 키
- 이 사이트가 네이버인걸 어떻게 증명하지?(디지털 서명)
- 네이버에서 우리에게 보내는 정보는 일부가 개인키로 암호화 되어 있음
- 네이버의 공개키로 알아볼 수 있는건 네이버의 개인키로 암호화된 정보들뿐
    - 여기서 개인키가 인코딩 키가 되고 공개키가 디코딩키가 된다.
- 공개키로 암호화 할때는 데이터 보안에 중점을 두고
- 개인키로 암호화 하면 인증과정에 중점을 둔다.(데이터 제공자의 신원확인 보장)

- 두개의 비대칭키를 사용
- 하나는 호스트 메세지를 인코딩하기 위함
- 다른 하나는 호스트의 메세지를 디코딩하기 위함.
- 인코딩 키는 모두를 위해 공개되어 있음.
    - 호스트 만이 개인 디코딩키를 알고 있다. (개인키)
- 노드 x는 자신의 인코딩 키 e^x를 공개적으로 배포 가능
    - 누구나 사용할 수 있는 인코딩키가 할당되어 있기에 공개킹 암호 방식은 대칭키의 쌍이 n^2만큼 늘어나는 것을 막을 수 있다.
- 그러나 x를 제외한 그 누구도 그 메세지를 디코딩 할 수 없음
    - 디코딩 개인키 d^x를 x만이 갖고 있기에
- 노드가 서버로 안전하게 메시지 발송하는 것을 더 쉽게 해줌
    - 서버의 공개키만 있으면 되기 때문
- 보안 프로토콜을 전 세계 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 함

[https://liveyourit.tistory.com/183](https://liveyourit.tistory.com/183)

- **대칭키와 달리 키의 개수를 줄일 수 있음**
    - **공유키는 여러가지여도 디코딩키 하나만 가지고 있어도 되기때문에**

### 4-1. RSA

- 공개키 (누구나 얻을 수 있음)
- 가로채서 얻은 암호문의 일부 (네트워크 스누핑해서 획득)
    - 네트워크 상의 정보를 염탐하여 불법적으로 얻는 것을 의미
- 메세지와 그것을 암호화한 암호문(인코더에 임의의 텍스트 넣고 실행해서 획득)

→ 이 모든 요구를 만족하는 공개키 암호화 체계 중 유명한 것이 RSA알고리즘

- 공개키, 평문의 일부, 공개키로 평문을 인코딩하여 얻은 평문에 대한 암호문, RSA 소스코드까지 주어졌다하더라도 암호를 크래킹하여 해당하는 개인키를 찾아내는 것 불가능

### 4-2. 혼성 암호 체계와 세션키

- 비대칭키는 누구나 공개키를 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼 수 있게 해주므로 훌륭
- 공개키 암호화 방식은 느림(실제로는 대칭과 비대칭을 섞은 것이 쓰임)
- 안전한 의사소통 채널을 수립할때는 공개키(비대칭키) 암호 사용
- 채널을 통해 임시의 무작위 대칭 키 생성하고 교환하여 이후의 나머지 데이터들 암호화 할때 빠른 대칭키 사용

## 5. 디지털 서명

- 암호체계는 메시지를 암호화하고 해독하는 것 뿐만 아니라 누가 메세지를 썼는지 알려주고 그 메세지가 위조되지 않았음을 증명하기 위해 **메세지에 서명**을 하도록 하는데 이용될 수 있음
- 디지털 서명은 인터넷 보안 인증서에 중요

### 5-1. 서명은 암호 체크섬

- 디지털 서명은 메세지에 붙어있는 특별한 암호 체크섬
    - 서명은 메세지를 작성한 저자가 누군지 알려줌
        - 저자의 극비 개인키를 갖고 있기 떄문에 오직 저자만이 이 체크섬 사용 가능
    - 서명은 메세지 위조를 방지
        - 악의적인 공격자가 송신중인 메세지를 수정했다면 체크섬은 더이상 그 메세지와 맞지 않을 것
        - 체크섬은 저자의 비밀 개인키와 관련되어 있기에 위조된 메세지에 대한 올바른 체크섬 날조할 수 없음
- 디지털 서명은 보통 비대칭 공개키에 의해 생성됨

## 6. 디지털 인증서

![Untitled](https://user-images.githubusercontent.com/85864699/211037724-a498fb87-d45f-43be-9bcb-9b584b804c55.png)

- 인터넷 신분증
- 신뢰할 수 있는 기관으로부터 보증받은 사용자나 회사에 대한 정보를 담고 있음

### 6-1. 인증서 내부

- 공식적으로 인증기관에 의해 디지털 서명된 정보의 집합이 담겨 있음.
- 구성요소
    - 대상의 이름(사람,서버 조직 등)
    - 유효 기간
    - 인증서 발급자(누가 이 인증서를 보증하는가)
    - 인증서 발급자의 디지털 서명
    - 서명 알고리즘에 대한 서술적인 정보뿐 아니라 대상의 공개키도 담고 있음
- 누구나 **디지털 인증서를 만들 수 있지만** 그 모두가 인증서의 정보를 보증하고 인증서를 개인 키로 서명할 수 있는 널리 인정받는 **서명 권한을 얻는 것은 아니다.**

### 6-2. X.509 v3인증서

- 디지털 인증에 대한 전세계 단일적인 표준은 없음
- 그러나 대부분의 인증서가 그들의 정보를 X.509라 불리는 표준화된 서식에 저장하고 있음.
- X.509 v3 인증서는 인증정보를 파싱 가능한 필드에 넣어 구조화 하는 표준화된 방법 제공
- X.509 v3인증서의 변종에는 **웹 서버 인증서**, 클라이언트 이메일 인증서, 소프트웨어 코드사인 인증서, 인증기관 인증서 등등

![image](https://user-images.githubusercontent.com/85864699/211037772-e9ee5724-0901-4671-bb8f-96a35e43474e.png)

### 6-3. 서버 인증을 위해 인증서 사용하기

- 유저가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져옴.
- 서버가 인증서를 갖고 있지 않다면 → 보안 커넥션 실패
- 필드
    - 웹 사이트의 이름과 호스트명
    - 웹 사이트의 공개키
    - 서명 기관의 이름
    - 서명 기관의 서명
- 절차
    1. 브라우저가 인증서 받으면 서명 기관 검사
        1. 만약 신뢰할만한 서명 기관이라면 브라우저는 이미 그곳의 공개키를 알고 있을 것
    2. 브라우저는 서명을 검증  (14-5 디지털 서명)
    
   ![image](https://user-images.githubusercontent.com/85864699/211037818-ae42f71c-a6b4-4e44-aa90-3e60a0a30ef8.png)
    1. 만약 서명 기관이 모르는 기관이라면 신뢰해야할 지 확신할 수 없기에 대개 사용자가 서명기관을 신뢰 하는지 대화 상자 보여줌.

## 7. HTTP 세부사항

- HTTPS는 HTTP의 가장 유명한 보안 버전
- HTTP 프로토콜에 대칭,비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것

### 7-1. HTTPS 개요

- HTTPS는 보안 전송계층을 통해 전송되는 HTTP
- 암호화 되지 않은 HTTP 메세지를 TCP를 통해 전세게의 인터넷 곳곳에 보내는 대신에 먼저 암호화하는 보안 계층
- HTTPS의 보안 계층은 SSL과 그것의 현대적 대체품인 TLS로 구현되어 있다.
- SSL(Secure Sockets Layer)은 [암호화](https://www.cloudflare.com/learning/ssl/what-is-encryption/) 기반 인터넷 보안 [프로토콜](https://www.cloudflare.com/learning/network-layer/what-is-a-protocol/)
    
    ![image](https://user-images.githubusercontent.com/85864699/211037944-aa9287ff-870e-4f8c-9fa8-f5769e2aac67.png)
    

### 7-2. HTTPS 스킴

- 보안 HTTP는 선택적이기에 웹 서버로의 요청을 만들 때 우리는 웹 서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요.
- 이것은 URL의 스킴을 통해 이뤄짐
- 보안이 없는 일반적인 HTTP는 스킴 접두사가 http
- 보안이 되는 HTTPS 프로토콜에서 URL의 스킴 접두사는 https
- URL이 http 스킴을 갖고 있다면 → 80번 포트로 연결, https 스킴을 갖고 있다면 → 443번 포트로 연결
- 서버와 바이너리 포멧으로 된 몇몇 SSL 보안 매개변수를 교환하면서 핸드셰이크를 하고 암호화된 HTTP 명령이 뒤를 잇는다.
- SSL 트래픽은 바이너리 프로토콜이기에 다른 포트 (보통 SSL은 443번 포트)로 전달
- 만약 SSL과 HTTP 트래픽 모두가 80번 포트로 도착 → 대부분의 웹 브라우저는 바이너리 SSL 트래픽을 잘못된 HTTP로 해석하고 커넥션을 닫을 것

### 7-3. 보안 전송 셋업

- 암호화 되지 않은 HTTP
    - 클라이언트는 웹서버의 80번 포트로 TCP 커넥션을 열고, 요청 메세지 보내고, 응답 메세지 받고, 커넥션을 닫는다.
- HTTPS
    - 클라이언트는 먼저 웹 서버의 443번 포트로 연결
    - TCP연결이 되고 나면 클라이언트와 서버는 **암호법 매개변수(ㅋ와 교환 키 협상(너 뭘로 암호화 했어? RSA인지 뭔지?)**하면서 SSL 계층 초기화
    - 핸드 셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메세지를 보안계층에 보낼 수 있음
    - 이 메세지는 TCP로 보내지기전에 암호화됨.
    
    🎵 **교환키 협상**이란 뭘까요? (몰라서 질문하는 겁니다)
    
    - 두 당사자 간에 사전에 준비된 키가 없어도, 안전하지 못한 채널을 통해서도 동일한 비밀키를 공유할 수 있게끔 일련의 패킷등을 교환해가며 대칭키를 합의 하는 과정
    - 직접적인 키 교환은 아니지만 특정 규칙에 의해 각자 비밀키를 생성하더라도 결국 같은 비밀키를 갖게되는 합의 과정임
    
    ![image](https://user-images.githubusercontent.com/85864699/211037989-22515d26-6326-44de-942b-66d334584b22.png)
    

### 7-4. SSL 핸드쉐이크

- 암호화된 HTTP 메세지를 보낼 수 있게 되기 전에 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다
- 핸드셰이크에서 일어나는 일
    - 프로토콜 버전 번호 교환
    - 양쪽이 알고 있는 암호 선택
    - 양쪽의 신원 인증
    - 채널을 암호화하기 위한 임시 세션 키 생성

**🎵 어처구니 없는 질문일 수도 있는데 왜 hand-shake를 하는 걸까요?**

- 상대가 식별된 대상인지 알아야 하기 때문에 Hand-shake해야함
- **TCP 커넥션을 먼저 만들고 SSL 핸드셰이크를 한다! (중요!)**
- 암호화된 HTTP 데이터가 네트워크를 오가기도 전에 SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고 받는다.
- 과정
    
    ![Untitled](https://user-images.githubusercontent.com/85864699/211038000-74c23c9b-e589-4169-a842-15c3fe3b7e32.png)
    
    - SSL 보안 매개변수 핸드셰이크 키를 만든다.
    - 클라이언트가 암호후보들을 보내고 인증서 요구
    - 서버는 선택된 암호화 인증서를 보낸다.
    - 클라이언트가 비밀 정보를 보낸다. 클라이언트와 서버는 키를 보낸다.
    - 클라이언트와 서버는 서로에게 암호화를 시작한다고 말해준다.

### 7-5. 서버 인증서

- SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날려주는 상호인증을 지원한다.
- HTTPS 트랜잭션은 항상 서버 인증서를 요구하는데 조직의 이름, 주소, 서버 DNS 도메인 이름 그리고 그 외의 정보를 보여주는 X.509 v3에서 파생되는 인증서이다.

### 7-6. 사이트 인증서 검사

- SSL 자체는 사용자에게 웹서버 인증서를 검증할 것을 요구하지 않지만 최신 브라우저들 대부분은 인증서에 대해 간단하게 검사하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 제공
- 날짜 검사
    - 인증서 시작및 종료일 검사
- 서명자 신뢰도 검사
    - 모든 인증서는 서버를 보증하는 어떤 인증기관에 의해 서명
    - 누구나 인증서를 생성할 수 있지만 몇몇 CA는 인증서 지원자의 신원및 사업의 선량함을 입증하는 알기 쉬운 절차를 갖춘, 잘 알려진 기관이기에 브라우저는 신뢰할만한 서명 기관의 목록을 포함한 채로 배포된다.
- 서명 검사
    - 서명 기관이 믿을만 → 브라우저에 서명자의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성 검사
        
        **🎵 여기서 공개키는 디코딩키** 
        
- 사이트 신원검사
    - 다른 누군가가 다른이의 인증서를 복사하거나 트래픽을 가로채는 것을 방지하기 위해 대부분의 브라우저는 인증서의 도메인 이름이 대화중인 서버의 도메인 이름과 비교하여 맞는지 검사한다.
    - 만약 호스트 명이 인증서의 신원과 맞지 않는다면 사용자를 우선으로 생각하는 클라이언트는 반드시 이 사실을 사용자에게 알리거나 잘못된 인증서 에러와 함께 커넥션을 끊어야 한다.

### 7-7. 가상 호스팅과 인증서

- 가상 호스트(하나의 서버에 여러 호스트명)으로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로움
    - 몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원
    - 예를 들어 jungmin.com이 있을때 공식 이름은 jungmin.security.com이라 가정해보자.
    - 사용자가 jungmin.com으로 접속했다면 서버 인증서에 나열된 호스트명(jungmin.security.com)은 jungmin.com과 맞지 않기에 경고가 나타남.
    - 모든 사용자를 jungmin.security.com으로 리다이렉션 시킴!

### 7-9. 프락시를 통한 보안 트래픽 터널링

- 클라이언트들은 종종 그들을 대신해서 웹 서버에 접근해주는 웹 프락시 서버를 이용한다.
- 많은 회사가 기업 네트워크와 공공 인터넷을 잇는 경계에 보안을 위한 프락시를 설치
- 프락시는 방화벽 라우터와 HTTP 트래픽의 교환을 허락한 유일한 장치이며, 바이러스 검사나 기타 콘텐츠 제어를 수행할 것
- 클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화했다면?
    - 더이상 HTTP헤더를 읽을 수 없음 (프락시가 못읽음)
    - 프락시는 요청을 어디로 보내야할지 모름
    - 어디에 보내야 할지 알려주는 기법 → HTTPS SSL 터널링 프로그램
- HTTPS SSL 터널링 프로토콜
    - 클라이언트는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를  말해줌
    - 클라이언트는 이 내용을 프락시가 읽을 수 있도로 암호화가 시작되기 전의 평문으로 말해줌
    - HTTP는 CONNECT라 불리는 새로운 확장 메서드 이용해서 평문으로 된 종단 정보를 전송하기 위해 사용됨
    - CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결을 해달라고 말해주며, 그것이 완료되면 데이터가 직접적으로 오갈 수 있게 해주는 터널을 만듦.
    - CONNECT 메서드는 안전한 원 서버의 호스트명과 포트를 콜론으로 구분된 형태로 제공하는 한줄 명령이다.
        
        ```java
        CONNECT home.netscape.com:443 HTTP/1.0
        User-agent: Mozila/1.1N
        
        <SSL로 암호화된 데이터가 오는 곳>
        ```
        
    - 클라이언트는 프락시로부터 응답을 기다리고 프락시는 요청을 평가하여 그것이 유효하고 사용자가 그러한 커넥션을 요청할 수 있도록 허가받았는지 확인
    - 모든것이 적법하다면 프락시는 목적지 서버로 연결하고 성공하면 200응답을 클라이언트에게 보냄