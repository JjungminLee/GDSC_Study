# 프락시(2)

## 📐 학습목표

- HTTP 프락시 요청이 서버요청과 어떻게 다른지, 프락시가 어떻게 브라우저의 동작을 미묘하게 바꾸는지 알아보자
- 일련의 프락시 서버들을 통과하는 메세지 경로를 Via 헤더와 TRACE메서드를 이용해 기록하는 방법 설명
- 프락시에 기반한 HTTP접근제어 설명
- 어떻게 프락시가 클라이언트와 서버 사이에서 각각의 다른 기능과 버전들을 지원하면서 상호작용할 수 있는지

## [학습목표 1] 프락시 요청의 미묘한 특징들

### 프락시 요청은 URI 서버 요청과 어떻게 다른가?

- 클라이언트가 프락시 대신 서버로 요청을 보내면 요청의 URI가 달라짐.
    - 웹서버로 요청을 보낼때는 스킴, 호스트, 포트번호가 없는 부분 URI를 가짐
    
    ```java
    GET /index.html HTTP/1.0
    ```
    
    - 클라이언트가 프락시로 요청을 보낼때는 완전한 URI를 가짐
    
    ```java
    GET http://www.marys.com/index.html HTTP/1.0
    ```
    

- 왜 웹서버와 프락시는 각각 다른 요청 형식을 가질까?
    - 단일 서버는 자신의 호스트명과 포트번호를 알고 있었기에 클라이언트는 불필요한 정보 발송을 피하기 위해 스킴과 호스트가 없는 부분 URI만 보냄
    - 프락시가 부상하면서 프락시는 목적지 서버와 커넥션을 맺어야 했기에 그 서버의 이름을 알 필요가 있었음
    - 서버로는 부분 URI를 프락시로는 완전 URI를 보내야한다.

![Untitled](https://user-images.githubusercontent.com/85864699/202098744-e68bdb90-9aeb-40f6-b6dd-c9afcff4a4c4.png)

### 가상 호스팅에서 일어나는 문제

- 가상으로 호스팅 되는 웹 서버는 여러 웹사이트가 같은 물리적 웹 서버 공유
- 요청이 온다면 웹서버는 요청이 접근하고자 하는 웹 사이트의 호스트명을 알 필요가 있음.
    - 가상으로 호스팅된 웹서버는 호스트와 포트에 대한 정보가 담겨있는 Host 헤더 요구함으로써 문제 해결
    - 명시적 프락시는 요청 메시지가 완전한 URI를 갖도록 함으로써 문제 해결
- **⚒️ 질문 : 명시적 프록시는 명시적으로 내가 프락시를 쓰겠다! 고 설정한 프록시죠? 만약에 프록시 설정을 하지 않았다면 클라이언트에서 원서버로 데이터가 가는거죠??**

### 인터셉트 프락시는 부분 URI를 받는다

- 지난 시간 개념정리!
    - 인터셉트 프락시 : 네트워크 단계에서 클라이언트에서 서버로 가는 요청을 가로채 프록시 서버로 캐시된 응답 전달 → 클라이언트에서 서버로 가는 트래픽 가로채기에 웹서버로 보내는 ‘부분 URI’ 얻을 것
    - 대리 프락시 : 웹 서버로 향하는 모든 요청 처리 + 필요할 때만 웹서버에 자원 요청 (원 서버의 호스트명과 아이피 주소 사용)
- 클라이언트가 HTTP를 올바르게 구현 → 명시적으로 설정된 프락시에 완전한 URI를 보낼 것
    - 🚨 ISSUE: 클라이언트는 자신이 프락시와 대화하는 것을 항상 알고 있는 것은 아님!
        - 몇몇 프락시는 클라이언트에게 보이지 않을 수 있음
        - 클라이언트가 프락시를 사용설정을 안함 → 그럼에도 클라이언트의 프락시는 대리 프락시나 인터셉트 프락시를 지날 수 있음
        
        ⇒ 클라이언트는 자신이 웹서버와 대화하고 있다고 생각하고 완전한 URI를 보내지 않을 것 !
        

### 프락시는 프락시 요청과 서버 요청 모두 다룰 수 있다

- 다목적 프락시 서버는 요청 메세지의 완전한 URI와 부분 URI 모두 지원해야 함.
    - if 명시적 프락시 요청 : 완전 URI
    - elif 웹 서버 요청 :가상 Host 헤더
    - else : 부분 URI
- 완전 URI와 부분 URI 사용하는 규칙
    - 완전 URI가 주어짐 → 프락시는 그것을 사용해야
    - 부분 URI O+ Host 헤더 → Host 헤더를 이용해 원서버의 이름과 포트번호 알아내야
    - 부분 URI O + Host 헤더 X
        - 프락시가 대리 프락시 → 프라시에 실제 서버의 주소와 포트번호 설정되어 있을 수 있음
        - 인터셉트 프락시가 원 IP주소와 포트번호 사용할 수 있게 함 → IP주소와 포트번호 모두 사용 가능
        - 모두 실패 → 프락시는 원 서버 알아낼 수 있는 충분한 정보 가지고 있지 않은 것이므로 에러메세지 반환해야

### 전송 중 URI 변경

- 사소한 URI 변경이라도 다운스트림 서버와 상호운용성 문제 일으킬 수 있음
    - 예를 들어 기본 HTTP 포트번호를 명시적인 :80으로 변경
    - 잘못 사용한 예약된 글자를 올바르게 이스케이프하여 교체
    
    ⇒ 모두 상호운영성 문제 일으킬 수 있음
    
- 다음 홉으로 보내기 전에 표준형식으로 ‘정규화’ 하기도 함
    - 홉:홉은 컴퓨터 네트워크에서 출발지와 목적지 사이에 위치한 경로의 한 부분
- 인터셉트 프락시가 URI를 전달할 때 절대 경로 고쳐쓰는 것 금지
    - 유일한 예외는 빈경로를 / 로 교체하는 것 뿐

### URI 클라이언트 자동확장과 호스트명 분석

- 프락시가 없다면 사용자가 타이핑한 URI를 가지고 그에 대응하는 IP주소를 찾음
    - 호스트명이 발견 → 그에 대응하는 IP주소들을 연결해 성공할때까지 시도
    - 호스트명이 발견 X → 사용자가 호스트명의 짧은 약어를 타이핑한 것으로 보고 자동화된 호스트명 확장을 제공하고자 함
- 확장?
    - 웹사이트 이름의 가운데만 입력하면 ‘www.’와 ‘.com’을 붙여줌
        - yahoo → www.yahoo.com
    - 해석할 수 없는 URI를 서드파티 사이트로 넘김
        - 오타교정 시도 → 사용자가 의도했을 URI 제시
    - 사용자가 호스트명 앞부분만 입력하면 자동으로 도메인 검색하도록 설정
        - oreilly.com

### URI 분석

- 프락시가 없는 경우
    - [과정]
        1.  oreilly 만 브라우저 URI창에 입력 
        2. oreilly를 호스트명으로, 기본스킴은 http:// , 기본 포트를 80 , 기본경로는 / 로 간주
        3. 브라우저는 호스트 oreilly 찾음 → 실패
        4. 브라우저는 호스트명 자동 확장 후 DNS에 ‘www.oreilly.com’의 주소분해 요청 → 성공
- 명시적 프락시를 사용할 때
    
    
    - 앞서 본 편리한 확장 수행 ❌❌
        - 브라우저는 명시적 프락시가 있는 경우 부분 호스트명을 자동 확장하지 않음
        - 브라우저의 URI를 프락시가 그냥 지나감
    - [과정]
        1. 사용자가 oreilly라고 타이핑
        2. 프락시가 명시적으로 설정 → 브라우저 DNS를 사용해 프락시 서버를 찾음
        3. 성공하면 프락시 서버 IP주소를 얻음
        4. 브라우저는 프락시에 접속하려고 함.
        5. 성공하면 커넥션이 맺어짐
        6. 브라우저는 HTTP 요청을 보냄
            1. 헤더를 보면 프락시는 프락시는 [http://oreilly/](http://oreilly/) 라고 보냄 
                1. why? : 클라이언트가 자동확장을 하지 않았기에 부분 호스트명을 얻음
                
- 인터셉트 프락시를 사용할 때
    - 서버로 커넥션이 만들어졌을 때 차이점이 발생
    - [과정]
        1. oreilly라고 타이핑
        2. 호스트 oreilly를 DNS 통해 찾아봄 → 실패
        3. oreilly를 ww.oreilly.com으로 자동 확장 → DNS 서버 성공, IP주소 브라우저에 반환
        4. 클라이언트는 성공할 때까지 IP주소에 대해 접속 시도 , **어떤 IP주소는 죽은 것일 수 있음!**
        5. 첫번째 접속 시도는 원서버가 아닌 프락시 서버에 의해 종료 → 클라리언트는 웹서버와 성공적으로 대화했다고 믿지만, 웹서버는 살아 있지도 않을 것
            
            **⚒️ 질문: 이게 정확히 무슨 말인지.. 그리고 웹서는 원서버 인가요?**
            
        6. 최종적으로 진짜 웹 서버와 상호작용할 준비가 되어 있을 때, 프락시는 그 IP주소가 실제로는 다운된 서버를 가리키고 있음을 알게될 것.
        7. 호스트명 다시 분석, 역방향 DNS 룩업을 해서든 아무튼 다른 IP주소 시도해야
    - 인터셉트 프락시, 명시적 프락시 모두 죽은 서버의 DNS 분석에 대한 장애 허용 지원 중요.
        - 명시적 프락시의 경우 장애 허용은 프락시에 달려있음
        
        **⚒️질문 : 그러면 인터셉트 프락시는??**
        

## [학습목표 2] 메시지 추적

- 웹 요청의 상당수가 프락시를 지나감.
- 프락시가 흔해지면서 → 프락시를 넘나드는 메세지의 흐름 추적하고 문제점 찾아내는 것도 중요한 일이됨.

### Via 헤더

![Untitled](https://user-images.githubusercontent.com/85864699/202098843-b5db1910-3e24-4cb4-81c1-e7a36801e8a1.png)

- 메시지가 지나는 각 중간노드(프락시나 게이트웨이)의 정보를 나열
- 메세지의 전달을 추적, 메시지 루프 진단, 요청을 보내고 그에 대한 응답을 돌려주는 과정에 관여하는 모든 메시지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용
- 네트워크 라우팅 루프 탐지하기 위해 사용
    
    ```java
    Via : 1.1 proxy-63.irenses-isp.net. 1.0 cache.joes-hardware.com
    ```
    
- 첫번째 프락시는 HTTP/1.1 프로토콜 구현, proxy-62.irenses-isp.net
- 두번째 프락시는 HTTP/1.0 프로토콜 구현, cache.joes-hardware.com으로 불림
- 문법
    - 헤더 필드는 쉼표로 구성된 경유지(waypoint) 의 목록
    - Via waypoint 는 이름,프로토콜 버전, 노드 이름, 코멘트의 최대 4개의 구성요소 담음
        - 프로토콜 이름
            
            → 중개자가 받은 프로토콜로, 만약 프로토콜이 HTTP라면 프로토콜 이름은 없어도 됨
            
        - 프로토콜 버전
            
            → 버전의 포멧은 프로토콜에 달려있음
            
            → HTTP의 경우 표준 버전 번호인 1.0,1.1이 사용됨 
            
            → 버전은 Via 필드에 포함되므로, 애플리케이션들은 중개자들이 어떤 버전을 다룰 수 있는지 알 수 있음
            
        - 노드 이름
            
            → 중개자의 호스트와 포트번호
            
        - 노드 코멘트
            
            → 중개자 노드를 서술하는 선택적인 코멘트 , 벤더나 버전정보 포함
            
- Via 요청과 응답경로
    - 요청메세지와 응답 메세지 모두 프락시를 지나기에 둘 모두 Via 헤더 가짐
    - 응답의 Via헤더는  요청의 Via헤더와 반대
        - 보통 같은 TCP 커넥션을 오가기 때문
- Via와 게이트웨이
    - 몇몇 프락시는 서버에게 비 HTTP프로토콜을 사용할 수 있는 게이트웨이 기능 제공
    - Via헤더는 이러한 프로토콜 변환 기록 → HTTP 애플리케이션은 프락시 연쇄에서 프토토콜 능력과 변환이 있었는지 알아차릴 수 있음
    - 아래 사진은 HTTP/FTP 게이트웨이가 받은 프로토콜 (FTP)에 대한 로그를 남기면서 Via헤더를 생성하는 것을 알 수 있다.
        
        ![Untitled](https://user-images.githubusercontent.com/85864699/202098961-2af85ffa-6793-4885-8dcd-bcc74759bf94.png)
        
        1. 클라이언트는 HTTP 요청을 게이트웨이 proxy.irens 어쩌구로 보낸다
        2. 프로토콜 게이트웨이로 동작하는 프록시는 FTP프로토콜을 이용해 FTP 서버로부터 원하는 객체 받아옴
        3. 프락시는 객체를 Via 헤더 필드와 함께 클라이언트에게 HTTP 응답으로 돌려줌
    
- Server 헤더와 Via헤더
    - Server 응답 헤더 필드는 원서버에 의해 사용되는 소프트웨어를 알려줌
    - 응답메시지가 프락시를 통과할 때, 프락시는 Server 헤더를 수정해서는 안됨. Server헤더는 원서버를 위해 존재하며 대신 프락시는 Via항목 추가해야
    
    ![Untitled](https://user-images.githubusercontent.com/85864699/202099035-55349f50-4c98-465a-88bc-6661ed825114.png)
    
    cf) cloud flare:클라우드플레어는 CDN 서비스와 분산 네임서버를 이용하여 사이트 성능과 속도, 보안을 향상시키는 서비스를 제공하는 기업
    
- Via가 개인정보 보호와 보안에 미치는 영향
    - Via 문자열 안에 정확한 호스트명이 들어가기 원하지 않는 경우가 있음
        - 프락시 서버가 네트워크 방화벽의 일부인 경우
            - 프락시는 방화벽 뒤에 숨어 있는 호스트의 이름과 포트를 전달해서는 안됨
        - 이름 전달이 가능하지 않다면 → 호스트명을 적당한 가명으로 교체
    

### TRACE 메서드

- HTTP 프락시 네트워크를 통해 홉에서 홉으로 전달될 때마다 메시지의 내용이 어떻게 변하는지 편리하게 관찰할 필요가 있음
- Trace 메서드는 요청 메시지를 프락시의 연쇄를 따라가면서 어떤 프락시를 지나가고 어떻게 각 프락시가 요청 메시지를 수정하는지 관찰/추적할 수 있게 해준다.
- 프락시 흐름을 디버깅하는데 매우 유용
- Max-Forwards
    
    ![Untitled](https://user-images.githubusercontent.com/85864699/202099145-0fc46416-c97a-44b6-a4c5-b4b90e20764e.png)
    
    - TRACE나 OPTIONS 요청의 프락시 홉 개수를 제한 하기 위해 Max-Forwards 헤더 사용
    - 전달되는 메시지가 무한루프에 빠지지 않는지 프락시 연쇄 테스트
    - 연쇄 중간 특정 프락시 서버 효과 체크할 때 유용
    - 어떤 특정 홉에서의 요청 보기 위해 사용
    - Max-Forwards의 값이 0 : 수신자는 자신이 원서버가 아니여도 TRACE 메시지를 전달하지 말고 반드시 클라이언트에 돌려줘야 함.

## [학습목표 3] 프락시 인증

- 프락시는 접근 제어 장치로서 제공되기도 함
- HTTP는 사용자가 유효한 접근 권한 자격을 프록시에 제출하지 않는한 콘텐츠에 대한 요청을 차단하는 프락시 인증 을 사용
- 인증에 참여하는 프락시가 프락시 연쇄상에 여러개 있을 때는 일반적으로 잘 동작하지 않음

## [학습목표 4] 프락시 상호운용성

- 프락시 서버는 서로 다른 프로토콜로 구현했을 수도 있고, 골치 아프게 이상한 동작을 할 수도 있는 클라이언트와 서버 사이를 중개해야함
- **지원하지 않는 헤더**
    - 프락시 서버는 넘어 오는 헤더 필드들을 모두 이해하지 못할 수 있음
    - 이해할 수 없는 헤더 필드는 반드시 그래도 전달해야함.
    - 같은 이름의 헤더 필드가 여러개 있는 경우 → 상대적인 순서도 반드시 유지
- **OPTIONS :어떤 기능을 지원하는지 알아보기**
    
    
    - HTTP OPTIONS 메서드를 통해 서버나 웹서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트가 알아볼 수 있게 해줌.
    - OPTIONS를 통해 서버의 능력을 먼저 알아낼수 있음
        
        ```java
        OPTIONS * HTTP/1.1
        ```
        
         *(별표) 이기에 서버 전체의 능력에 대해 묻는 것이 됨
        
    - URI가 아래와 같이 실제 리소스라면 OPTIONS 요청은 특정 리소스에 대해 가능한 기능들을 묻는 것
        
        ```java
        OPTIONS http://www.joes.com/index.html HTTP/1.1
        static HTML file wouldn't accept a POST method.
        ```
        
        ⚒️**질문: 이게 OPTIONS 헤더가 맞을까요…? ㅜㅜㅜ**
        
        ![Untitled](https://user-images.githubusercontent.com/85864699/202099490-3f2fe63b-c40d-4625-939d-1181f80b6419.png)
        
- Allow 헤더
    - 요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거
    - Allow:GET,HEAD,PUT
    - Allow 헤더는 새 리소스가 지원했으면 하는 메서드 추천하기 위해 요청 헤더로 사용되기도 함.
    - 서버는 추천받은 메서드 모두 지원해야할 의무 없음
    - 요청에 대한 응답에는 실제로 지원하는 메서드들을 열거하는 Allow헤더 포함시켜야함