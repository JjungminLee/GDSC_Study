# 20_리다이렉션과 부하균형

## 들어가기 전에

Elastic Beanstalk 로드밸런싱이 안돼서 30트를 했습니다.. 지금도 ing (지금은 성공 200)

![image](https://user-images.githubusercontent.com/85864699/227531776-252a38e4-2294-449f-b1e8-3869f4cdd259.png)

대충 HTTP 4xx에러를 뱉는다는 뜻 (클라이언트 오류 응답)

![image](https://user-images.githubusercontent.com/85864699/227531807-4701a529-8493-4035-bb43-692a431ab9d4.png)
환멸나는 헬스체킹…  위에 502빼곤 거의 200으로 뜨고 있어여… (36시간 끝에 해결)

환곤쿤 감사링…ㅜㅜㅜ

### 🧊 리다이렉션은 언제 사용할까?

- 메시지가 프락시, 캐시, 서버 팜의 특정 웹서버 중 어디에서 끝나는지 판별하기 위해 사용한다.
- 클라이언트 메세지를 명시적으로 요청하지 않은 곳으로 보낼 수 있다.

### 🧊  왜 리다이렉트 일까?

- 신뢰할 수 있는 HTTP 트랜잭션 수행
- 지연 최소화
- 네트워크 대역폭 절약

리다이렉션 == 최적의 분산된 콘텐츠를 찾는 것을 도와주는 기법의 집합

리다이렉션과 부하균형은 짱친

- 들어오는 메세지의 부하를 서버들의 집합에 분산하기 때문!

### 🧊 리다이렉트 할 곳

- 서버, 프락시, 캐시, 게이트웨이 (클라이언트 입장에서는 모두 서버)
- 웹서버
    - IP별로 요청을 다룬다.
    - 똑같이 복제된 서버들로 요청을 분산하는 것은 같은 URL에 대해 여러 곳에서 온 요청들을 각각 최적의 웹서버로 보내겠다는 뜻.
    - 프락시는 프로토콜 별로 요청을 다룬다.
        - 모든 HTTP 트래픽은 프락시를 거쳐야 한다.
        - 클라이언트 근처에 프락시 캐시가 있다면 모든 요청이 프락시 캐시로 흘러들어가는 것이 이상적이다.

### 🧊 일반적인 리다이렉션 방법

1. HTTP 리다이렉션
![image](https://user-images.githubusercontent.com/85864699/227531924-a64a0e7f-2fa9-48fc-a586-d16dfa99588f.png)
- 요청을 처리하는 서버는 가용한 것들 중 부하가 가장 적은 콘텐츠 서버를 찾아서 브라우저의 요청을 그 서버로 리다이렉트
- 리다이렉트 하는 서버가 클라이언트의 아이피 주소를 안다는 것이 특징
- HTTP 리다이렉션은 서버로 향하는 요청의 방향을 변경할 수 있지만 단점이 몇가지 있음
    - 어떤 서버로 리다이렉트 할지 결정하려면 원서버는 상당히 많은 처리를 해야한다.
    - 페이지 접근 할때마다 두번의 왕복이 필요하기 때문에 사용자가 더 오래 기다리게 된다.
    - 리다이렉션 서버가 고장나면 사이트도 고장남 ㄴㅇㄱ

1. DNS 리다이렉션
- 도메인 이름이 항상 IP주소로 분석되어야 함.
- DNS 분석자 → 클라이언트의 os / 클라이언트의 네트워크에 있는 DNS서버이거나 더 원격에 있는 DNS서버 일 수도 있음
- 분석자가 어떤 아이피를 반환할 것 인가를 결정하는 방법은 단순한 라운드 로빈부터 복잡한 것 (여러서버의 로드를 검사해서 로드가 가장 적은 서버의 아이피를 반환하는 것 )까지 다양함
- **DNS 라운드 로빈**
    - 라운드 로빈 DNS는 **지리적으로 복수의 웹 서버가 멀리 떨어져 있어서 실시간으로 헬스 체크가 어려울 때 사용**한다. 혹은 적은 비용으로 구현이 필요할때 사용하기도 한다.
    - **순서대로 돌아가면서 (보통 시간 단위) 각각의 서버로 트래픽을 분산시켜서 처리하는 알고리즘**
    이다.
- 다중 주소와 라운드로빈 주소 순환
    - 대부분 DNS 클라이언트는 다중 주소 집합의 첫번째 주소를 사용하지만 부하 균형을 위해 룩업이 끝났을 때 마다 주소를 순환 시킨다. (이렇게 안하면 첫번째 서버가 모든 부하를 받을 것 아야…)
- **DNS 캐싱의 효과**
    - DNS 주소 순환 == 부하 순환
    - DNS 룩업을 했을 때 그 주소를 몇번이고 다시 재 사용 → 비용을 줄인다, 같은 클라이언트와 선호하는 서버들에게 유용
    - [질문] DNS 룩업이라는게 로드벨런싱할 서버의 주소들을 가져오는 건가요?
- **다른 DNS 기반 리다이렉션 알고리즘**
    - 주소를 가져오는 방법은 이제 알았으니 주소의 순서를 결정하기 위해 사용하는 기법들을 알아보자!
        - 부하 균형 알고리즘
            - 가장 로드가 적은 웹 서버를 목록의 가장 위에 놓는다.
        - 근접 라우팅 알고리즘
            - 웹서버들의 팜이 지리적으로 분산되어 있는 경우, DNS서버는 사용자를 근처의 웹서버로 보내는 시도를 한다.
        - 결합 마스킹 알고리즘
            - DNS 서버는 헬스채킹하고 요청을 정전이나 기타 장애를 피해서 라우팅한다.

1. 임의 캐스트 어드레싱
- 여러 지리적으로 흩어진 웹 서버들은 정확히 같은 아이피 주소를 갖고 클라이언트 요청을 클라이언트에서 가장 가까운 서버로 보내주기 위해 백본 라우터의 ‘최단거리’ 라우팅 능력에 의지한다.
    - back-bone?
        - 기업 전산망의 근간이 되는 네트워크를 연결시켜주는 고속 통신망.
- 각 웹 서버에게 자신을 인접한 백본 라우터라고 광고
- 웹서버는 라우터 통신 프로토콜을 이용해 자신과 인접한 백본 라우터와 대화
- 백본 라우터가 임의 캐스트 주소를 목적지로 하는 패킷을 받았을 때 아이피 주소를 받아들일 수 있는 가장 가까운 라우터부터 찾는다

1. 아이피 맥 포워딩
- 들어가기 전에 질문: 스위치가 뭔가여? 구글링해보니 대부분 L4스위치 (여기서 L이 레이어를 의미하나봐여..) 이고 로드벨런싱을 수행한다고 하네여 이게 맞겠죠…?
- HTTP 메세지의 각 패킷은 출발지와 목적지의 아이피 주소와 TCP 포트번호로 이루어진 레이어-4의 주소(Application Layer ⇒ 걍 http로 봐도 될 것 같아여)를 가지고 있음
- 패킷은 레이어-2 장비(스위치나 허브)가 주의를 기울어야 하는 레이어-2 주소인 미디어 접근 컨트롤 (MAC)의 주소도 가지고 있음
- 레이어-2 장비의 역할은 들어오는 특정 맥 주소의 패킷을 받아서 나가는 특정 맥 주소로 포워딩
- MAC 포워딩을 지원하는 레이어-4 스위치는 보통 요청을 여러 프락시 캐시로 보낼 수 있고, 그들 사이의 부하균형을 유지할 수 있다 (점대 점으로만 가능하기에 서버와 프락시는 스위치와 한 홉거리에 위치해야)

1. 아이피 주소 포워딩
- 패킷을 목적지 맥주소가 아닌 목적지 아피 주소의 변경에 따라 라우팅 한다.
    - 목적지 서버가 한 홉거리에 있을 필요가 없다.
    - 스위치에서 업스트림의 위치를 판별할 수만 있다면 일반적인 레이어-3 종단간 인터넷 라우팅이 패킷을 올바른 위치로 보내준다.
- 라우터 대칭성
    - 스위치는 받아온 커넥션을 통해 클라이언트에게 응답을 돌려줘야 함
    - 응답의 귀환경로를 제어할 수 있는 방법
        1. 패킷의 출발지 아이피 주소를 스위치의 아이피 주소로 바꾼다.
        - 응답 패킷을 스위치로 가게 한다.
        1. 출발지 아이피 주소가 그 클라이언트의 아이피 주소로 계속 남아있다면 서버에서 클라이언트로 바로 가는 경로가 존재하지 않아야 한다. 
        - 장점:서버가 클라이언트의 아이피 주소 얻는다
        - 단점:클라이언트와 서버 사이 네트워크 전체에 약간 통제가 필요함
1. 네트워크 구성요소 제어 프로토콜
- 아이피 패킷을 전달하는 라우터나 스위치 같은 네트워크 구성요소들이 웹서버나 프락시 캐시와 같이 애플리케이션 요청을 처리하는 서버 구성요소들과 대화할 수 있게 해준다.

### 🧊  왜 이정민은 36시간 동안 로드밸런싱에서 헤맸을까?

- Elastic Beanstalk에서 로드밸런싱을 쓰는 법

![Untitled](20_%E1%84%85%E1%85%B5%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%87%E1%85%AE%E1%84%92%E1%85%A1%E1%84%80%E1%85%B2%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%20d54cd4b403474208b128f41428f9b0c2/Untitled%203.png)

보통은 Application 로드밸런서를 씁니다. Application Layer를 다루는 로드밸런서 입니다!

HTTP와 HTTPS, 웹소켓을 활용하는 로드벨런서 입니다.

HTTP를 활용한 라우팅(부하분산)을 하고 기본 알고리즘은 라운드 로빈을 수행한다고 해요!

만약 EC2에 할당한 요청 작업이 오래걸린다면 균형이 꺠질 수 있습니다. 그래서 Least Outstanding Requests를 활용해 처리 되지 않은 요청을 가장 적게 갖고 있는 EC2인스턴스에게 할당합니다!

그래서 아무튼 이슈해결은

4xx에러니까 리다이렉션과 헬스체킹에서 문제가 있을것이라 판단.

근데 403포트로 https리다이렉션을 시켜주지 않아서 리다이렉션보다 헬스체킹 문제라고 판단

해결방법

- 4xx에러를 막는 conf파일 삽입
- 헬스 체킹 경로가 루트 경로 였는데 스프링부트 controller에 “/”경로에 대한 api를 만들어줌 (헬스체킹하는 경로가 실제 url에 없었기에)
- [https://meaningland02.tistory.com/62](https://meaningland02.tistory.com/62)
