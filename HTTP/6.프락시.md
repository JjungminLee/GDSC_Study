# 📐 학습 목표

- 프락시 vs 웹 게이트웨이
- 실제 네트워크에 프락시가 어떻게 배치되어 있을까? + 트래픽이 어떻게 프락시 서버로 갈까?
- 브라우저에서 프락시를 사용하려면?
- 프락시 요청과 서버요청의 차이점, 어떻게 프락시는 브라우저의 동작을 미묘하게 바꿀까?
- 프락시 서버를 통과하는 메세지 경로
- 프락시에 기반한 HTTP 접근제어
- 프락시가 어떻게 각각 다른 기능과 버전 지원하면서 클라이언트와 서버 사이에서 상호작용을 할 수 있을까?

# 프락시

- 웹 서버의 중개자
- 클라이언트와 서버 사이에 위치
- 클라이언트가 트랜잭션을 완료한다는 것은 변하지 않음
- 클라이언트이기도 하면서 웹 서버

## 개인 프락시와 공용 프락시

- 개인 프락시 : 하나의 클라이언트만을 위한 프락시
- 공용 프락시 : 여러 클라이언트가 함께 사용
- 공용 프락시
    - 대부분의 프락시
    - 중앙 집중형 프락시를 관리하는게 더 효율적
- 개인 프락시
    - 흔하진 않지만 꾸준히 사용(클라이언트 컴퓨터에서 실행)

## 프락시 vs 게이트 웨이

![Untitled](https://user-images.githubusercontent.com/85864699/201508931-01c91962-6a18-4c06-a1b0-aaca6840e474.png)

- 프락시 : **같은** 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결
- 게이트웨이 : 서로 **다른** 프로토콜을 사용하는 둘 이상 연결
    - 서버가 서로 다른 프로토콜로 말하더라도 서로 간의 트랜잭션 완료할 수 있도록 프로토콜 변환기 처럼 동작

# 왜 프락시를 사용하는가?

- 보안개선, 성능을 높여줌, 비용 절약
- 모든 HTTP 트래픽을 들여다보고 건드릴 수 있음
- **어린이 필터**
- **문서접근제어자**
    - 많은 웹서버들과 웹 리소스에 대한 단일한 접근제어 전략 구현 +감사추적하기 위해 사용
    - 각기 다른 조직에서 관리 되는 다양한 종류의 수많은 웹서버들에 대한 접근제어를 수시로 갱신할 필요 없이 중앙 프락시 서버에서 접근 제어 설정 가능
- **보안 방화벽**
    - 조직 안에 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 네트워크의 한 지점에서 통제
    - 바이러스를 제거하는 웹이나 이메일 프락시가 사용할 수 있는 트래픽을 세심히 살펴볼 수 있는 후크 제공
    - 후킹 공격 → 특정 트래픽 가로채 정보 빼돌리는 것
- **웹 캐시**
    - 인기 있는 문서의 로컬 사본 관리 + 해당 문서에 대한 요청이 오면 빠르게 제공하여 느리고 비싼 인터넷 커뮤니케이션 줄임
    - 중간에 필요한 문서 바로바로 전송
- **대리 프락시**
    - 서버 바로 앞에 있음
    - 웹 서비인것 처럼 위장
    - 진짜 웹 서버 요청을 받지만 웹 서버와 달리 요청 받은 콘텐츠의 위치 찾아내기 위해 다른 서버와 커뮤니케이션 시작
    - 공용 콘텐츠에 대한 느린 웹서버의 성능 개선하기 위해 사용됨.
    - 서버 가속기라고 부름
    - 콘텐츠 라우팅 기능과 결합되어 주문형 복제 콘텐츠의 분산 네트워크 만들기 위해 사용됨 **(한 서버만 모든 일을 하면 안되니까 프락시에서 한번 거쳐서 여러 원 서버로 뿌려주는것 → 부하분산)**
- **콘텐츠 라우터**
    - 인터넷 트래픽 조건과 콘텐츠 종류에 따라 요청을 특정 웹서버로 유도하는 콘텐츠 라우터로 동작
    - A는 복제 캐시로 콘텐츠 분산하기 위해 (더 높은 성능을 위해) 돈을 지불 → A의 페이지에 대한 요청은 복제 캐시로 보냄.
    - B는 돈을 지불 하지 않으면 → 요청을 원서버로 보냄.
- **트랜스 코더**
    - 콘텐츠를 클라이언트에게 전달하기 전에 본문 포맷 수정 가능
    - 데이터 표현 방식을 자연스럽게 변화하는 것을 트랜스 코딩이라고 함.
    - 트랜스코딩 프락시는 크기 줄이기 위해 GIF 이미지를 JPG로 변환하기도 함
- **익명화 프락시**
    - HTTP 메세지에서 신원을 식별할 수 있는 특성(IP주소,From헤더, 쿠키 등등)을 적극 제거함으로써 개인정보 보호와 익명성 보장에 기여

# 프락시는 어디에 있지?

- 어떻게 네트워크에 배치되는가?
- 어떻게 프락시의 연쇄가 계층을 이루는가?
- 어떻게 트래픽이 올바르게 프락시를 찾아가는가?

## 프락시 서버 배치

- 출구 프락시
    - 로컬 내트워크의 출구에 놓기
    - 예시: 초등학교에서 부적절한 콘텐츠 브라우징 막기 위해 필터링 출구 프락시 사용
- 접근(입구) 프락시
    - 고객으로 부터 모든 요청 종합 처리 위해 ISP접근 지점에 위치
    - 다운로드 속도 개선, 인터넷 대역폭 줄이기 위한 캐시 프락시
- 대리 프락시
    - 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치
    - 웹 서버로 향하는 모든 요청 처리 + 필요할 때만 웹서버에 자원 요청
    - 보안 기능 추가 + 웹 서버 캐시를 느린 웹 서버 앞에 놓음으로써 성능 개선
    - 웹서버의 이름과 IP주소로 스스로를 가장 → 모든 요청은 서버가 아닌 대리 프락시로 향함
- 네트워크 교환 프락시
    - 캐시 이용 → 충분한 처리 능력 갖춘 프락시가 네트워크 사이의 인터넷 피어링 교환 지점들에 놓임

## 프락시 계층

- 프락시 계층 → 연쇄 구성
- 프락시 서버들이 부모와 자식 관계 가짐
- 부모 프락시는 **서버와 가까운** 프락시, 자식 프락시는 **클라이언트와 가까운** 프락시
- 프락시 계층 콘텐츠 라우팅
    - 정적 콘텐츠 라우팅
    - **동적 콘텐츠 라우팅**
        - 요청된 객체가 콘텐츠 분산을 위해 돈을 지불한 웹서버에 속하면 → 요청을 가까운 캐시 서버에 보냄 (캐시는 객체 반환 or 없다면 서버에서 가져오기)
        - 요청이 특정 이미지에 대한 것이라면, 압축 프락시에 들어가서 느린 모뎀이라도 클라이언트가 빠르게 다운하도록 변경
    - 이처럼 상황에 맞게 부모 프락시나 원서버에 라우팅
    - 동적 부모 선택
        1. 부하균형
            
            → 자식 프락시는 부하 분산하기 위해 현재 부모들의 작업량에 근거하여 부모 프락시를 고른다.
            
        2. 지리적 인접성에 근거한 라우팅 
            
            → 자식 프락시는 원서버의 지역을 담당하는 부모 선택 가능
            
        3. 프로토콜/타입 라우팅
            
            → 자식 프락시는 URI에 근거하여 다른 부모나 원서버로 라우팅 가능.
            
            → 특정 종류의 URI를 갖고 있는 요청의 경우, 특별한 프락시 서버로 보내져 특별한 프로토콜로 처리됨
            
        4. 유료 서비스 가입자를 위한 라우팅
            
            → 빠른 서비스를 위해 추가금을 지불했다면, URI는 대형 캐시나 성능 개선을 위한 압축엔진으로 라우팅됨.
            
        
    

## 프락시는 어떻게 트래픽을 처리하는가?

클라이언트 트래픽이 프락시에 가도록 만드는 방법

1. 클라이언트 수정
    1. 크롬 같은 브라우저는 수동 혹은 자동 프락시 지원
    2. HTTP 요청을 의도적으로 원서버가 아닌 프락시로 보냄
2. 네트워크 수정
    1. 네트워크 인프라를 가로채서 웹 트래픽이 프락시로 가게 하는 것 → 인터셉트 프락시
3. DNS 이름공간 수정
    1. 대리프락시가 웹 서버의 이름과 IP주소를 자신이 직접 사용 → 모든 요청은 서버 대신 대리 프락시로 감.
    2. DNS 이름 테이블을 수동으로 편집하거나 사용할 적절한 프락시나 서버를 계산해주는 특별한 동적 DNS 서버를 이용해 조절 가능
4. 웹 서버 수정
    1. HTTP 리다이렉션 명령을 클라이언트에게 돌려줌으로써 클라이언트 요청을 프락시로 리다이렉트 하도록 설정 가능
    2. 리다이렉트 받는 즉시 클라이언트는 프락시와 트랜잭션 시작

## 클라이언트 프락시 설정

- 수동설정
    - 프락시 사용하겠다고 명시적 설정
    - 단순하지만 유연하지 못함
    - 모든 콘텐츠를 위해 단 하나의 프락시 서버만을 지정할 수 없음, 장애시 대체 작동에 대한 지원 없음
    - 큰 조직에서는 관리 문제 야기
- 브라우저 기본 설정
    - 브라우저 벤더나 배포자는 브라우저를 소비자에게 전달하기 전에 프락시 미리 설정해 놓을 수 있음
- 브라우저 자동설정 (PAC)
    - 클라이언트는 프락시를 써야하는지, 그렇다면 어떤 프락시를 써야하는지 판단 위해 자바스크립트 파일 가져와서 실행
    - 문서에 접근할 때 마다 자바스크립트 함수가 적절한 프락시 서버 선택
    - 프락시 설정을 그때그때 상황에 맞게 계산
    - 자바스크립트 PAC 파일의 URI를 브라우저에 설정해야함
- WPAD 프락시 발견
    - 브라우저는 자동설정 파일을 다운받을 수 있는 ‘설정서버’를 자동으로 찾아주는 웹 프락시 자동발견 프로토콜(WPAD)제공
    - 브라우저에게 알맞은 PAC파일을 자동으로 찾아주는 알고리즘
    - 클라이언트가 하게 될 일
        1. PAC URI를 찾기 위해 WPAD 사용
        2. 주어진 URI에서 PAC파일 가져옴
        3. 프락시 서버 알아내기 위해 PAC파일 실행
        4. 알아낸 프락시 서버 이용하여 요청 처리
    - WPAD가 올바른 PAC 파일을 찾아내기 위해 일련의 리소스 기법 사용
        - 동적 호스트 발견 규약(DHCP)
        - 서비스 위치 규약(SLP)
        - DNS 잘 알려진 호스트명
        - DNS SRV레코드
        - DNS TXT 레코드 안의 서비스 URI

# 💡 단어정리

### SOCKS(Socket Secure)

→  프록시 서버를 통해 클라이언트와 서버간에 네트워크 패킷을 교환하는 인터넷 프로토콜이다.

# 💡 생각해볼 것들

### **프락시와 vpn의 차이**

- [공통점] 먼거리에 있는 컴퓨터와 자신의 컴퓨터를 이어주며, 보안성을 높여주는 역할
- [차이점]
    - 프록시:  IP우회 같은 사소한 목적 , **IP주소 숨기기만 할 뿐** 데이터 내용 암호화하지 않음.
    - VPN: 전송내용 암호화, 스누핑(네트워크 상의 정보를 염탐하여 불법적으로 얻는 것) 피하기, 우리의 요청과 응답결과를 암호화 한 뒤에 전달하기 떄문에 중간에 다른 사용자가 데이터를 탈취해도 무슨 내용인지 알 수 없음

### **referer 헤더**

- HTTP 헤더 중 하나
- 현재 표시하는 웹페이지가 **어떤 웹페이지에서 요청되었는지 알 수 있으며,** 어떤 웹사이트나 웹서버에서 **방문자가 왔는지 파악할 수 있는** 기능을 함
- 전체 경로 (URI정보)를 알고 싶다면 헤더의 Referer를 참조하면 됨
- 결국 referer의 값은 이 **페이지를 요청한 이전 페이지가 무엇인지를 알려주는 정보**이다.
- referer는 보통 **로그 분석**이나 **접근 제어**를 할 때 이용한다

[[WEB] 📚 HTTP referer 란?](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-HTTP-referer-%EB%9E%80)

### ISP란?

- 인터넷 서비스 제공자로, 인터넷 서비스를 제공하는 업체를 뜻함

[https://economic-alphabet-127.notion.site/6-1-0e4eea9b49c24a6bafe8342bea77a1fd](https://www.notion.so/0e4eea9b49c24a6bafe8342bea77a1fd)

### 웹 브라우저에 www.naver.com을 입력하면 일어나는일

- 널럴한 개발자 강의

[https://www.youtube.com/watch?v=GAyZ_QgYYYo](https://www.youtube.com/watch?v=GAyZ_QgYYYo)

1. OS (window)
    1. host파일에 뭐라고 썼는지 뒤지기
        
        → 항상 dns에게 물어보는 것이 아님
        
    2. DNS 응답 캐싱
    3. 캐시 결과를 보고 없으면 DNS에 질의
2. NAT(공유기)
    1. 공유기 설정에 따라 DNS응답.
3. ISP(Internet)
    1.  공유기 설정이 없으면 ISP 설정에 따라 직접 DNS질의
4. Naver의  IP주소 받아옴
    1. IP주소로 TCP연결(HTTP)
5. HTTP Request
6. HTTP Response

## GSLB ,  CDN

### **로드 밸런싱**

- 부하분산
- 컴퓨터 자원들에게 작업을 나누는 것
- scale up : 서버 자체의 성능을 높이는 것
- **scale out: 여러 대의 서버를 두는 것**
- **로드 밸런서 vs 리버스 프록시**
    
    로드밸런싱 장치와 프록시는 서로 혼용되어 사용이 가능한 용어다. 모든 프록시가 로드밸런서는 아니지만 대다수의 프록시는 기본적으로 로드 밸런싱이 가능하다. 로드밸런서가 실제 프록시가 아니라고 주장이 가능하지만, 이런 세밀한 구별을 통해 복잡성을 높일 필요는 없다.
    
- 로드 밸런싱 알고리즘
    - 라운드로빈
        
        ![Untitled](https://user-images.githubusercontent.com/85864699/201508955-dfe85a49-d54f-4828-88d7-11ab2d08a0e6.png)
        
        → 서버에 들어온 요청을 순서대로 돌아가며 배정
        
        → 서버와의 연결이 오래 지속되지 않는 경우 적합
        
        → 웹서버는 자신의 공인 IP를 가지고 있는데 웹 사이트에 접속 원하는 사용자가 해당 도메인 주소를 브라우저에 입력하면 DNS는 도메인 정보를 조회하는데, 이때 IP주소 여러개를 서버 IP리스트 중에서 라운드로빈 형태로 랜덤하게 하나 혹은 여러개를 선택하여 사용자에게 알려줌
        
        → 웹 서버에 접속하는 다수의 사용자는 복수의 웹 서버에 나위어 접속하게 되면서 자연스럽게 서버 부하 분산
        
        → 보통 지리적으로 복수의 웹서버가 멀리 떨어져 있어서 실시간 헬스체크가 어려울때 사용 (라운드로빈 dns는 로드밸런싱 기능이 없다)
        
        [https://m.blog.naver.com/techtrip/221691155719](https://m.blog.naver.com/techtrip/221691155719)
        
    - 가중 라운드로빈 방식(Weighted Round Robin Method)
        - 각 서버마다 가중치 매기고 가중치 높은 서버에 클라이언트 요청 우선 배분
    - IP 해시 방식
        - 클라이언트 **ip주소를 특정 서버로 매핑**하여 요청 처리
        - 사용자 ip를 해싱해 로드 분배, 사용자가 항상 동일한 서버로 연결되는 것 보장
        - Hashing:  임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 매핑하는 것, 또는 그러한 함수
    - 최소 연결방식
        - 요청이 들어온 시점에 가장 적은 연결 상태 보이는 서버에 우선적으로 트래픽 배분
    - 최소 응답시간 방식
        - 서버의 현재 연결 상태와 응답시간을 모두 고려하여 트래픽 배분
        - 가장 적은 연결상태와 가장 짧은 응답시간을 보이는 서버에 우선적으로 로드 배분하는 방식

### **GSLB**

![Untitled](https://user-images.githubusercontent.com/85864699/201508969-07d4b4c3-0d0c-416d-80bd-39471a6f25db.png)

- 네이버나 구글정도의 회사는 GSLB를 구현해놓음
- DNS 발전시킨 형태
- 기존의 로드 밸런싱과는 차이가 있음.
- 재해 복구(DR)
    - 실패에 대해 대체할 수 있는 서버 제공
- 지역적인 부하분산
    - 많은 트래픽을 여러 서버로 분산
- 응답시간 중심의 서비스를 제공 가능하게 할 수 있음.
    - Client위치나 네트워크 기반.
- GSLB 주요기술
    - Health check
    - TTL (Time To Live :패킷의 생존시간)
    - 네트워크 거리 및 지역
- CMD에 쳐보자

![Untitled](https://user-images.githubusercontent.com/85864699/201509001-29ef42b0-e97f-4e49-a0ad-76198aa98c32.png)

- nheos는 dns의 full name 보통 akamai 같은게 뜨는데 이게 CDN 제공하는 곳 이름
- 이름에 대한 Address는 그때 그때 달라질 수 있다!
    - PC가 접속자의 ip를 보고 CDN의 DB에서 접속자의 위치 파악
    - 접속자가 서울에 있구나 → 어떤 ip주소로 접속하면 빠르겠구나를 파악
    - naver의 ip주소가 1개가 아니라 n개가 있음
- Health check
    - 서버가 죽어버렸을수도 있음
    - 서버가 다운됐을 때 다른 가까운 서버로 연결시켜주는 역할
- GSLB VS DNS
    
    
    |  | GSLB | DNS |
    | --- | --- | --- |
    | 재해 복구 | 서버의 상태를 모니터링 (Health Check) 실패한 서버의 IP는 응답에서 제외 | 서버의 상태를 알 수 없다. 서비스를 실패하는 유저 발생 |
    | 로드밸런싱 | 서버의 로드 모니터링하여 로드가 적은 서버의 IP를 반환하는 방식 가능 | Round Robin 방식사용. 정교한 로드 밸런싱이 되지 못함 |
    | 레이턴스 기반 | 지역별 latency 정보를 가져 유저에게 더 적은 latency를 가지는 서버로 연결 | Round Robin. 네트워크상 멀리 떨어진 위치의 서버로 연결할 수 있다. |
    | 위치기반 서비스 | 유저의 지역 정보를 기반, 해당 지역을 서비스하는 서버로 연결 | Round Robin |
    
    [https://ckddn9496.tistory.com/33](https://ckddn9496.tistory.com/33)
    

### CDN

- GSLB를 구현하는 방법 중 서비스 구현이 있음 → 그 중 서비스 구현이 CDN
- 네이버 같은 회사는 GSLB 또는 CDN을 적용
- CDN(콘텐츠 배달 네트워크)은 사용자에게 웹 콘텐츠를 효율적으로 제공할 수 있는 서버의 분산 네트워크
- 전세계에 네트워크를 분산시켜 HTML,CSS,JS 같은 리소스들을 빠른 속도로 다운받을 수 있게 함.
- ddos같은 서버 다운을 시킬 수 있는 악의적 공격을 방어하는데도 매우 효울적
- CDN은 최종 사용자와 가까운 POP(point-of-presence) 위치의 에지 서버에 캐시된 콘텐츠를 저장하여 대기 시간을 최소화
- CDN을 사용하는 이유
    - 특히 콘텐츠를 로드하기 위해 많은 왕복이 필요한 애플리케이션을 사용 중인 최종 사용자에게 더 나은 성능 및 향상된 사용자 환경 제공
    - 제품 런칭 이벤트 시작같이 순간적인 높은 부하를 더 효율적으로 처리하기 위한 대규모 크기 조정.
- 미국에 있는 사용자가 한국의 컨텐츠 가져오려고 하면 거리가 멀기 때문에 가져오는 속도가 느릴 것 CDN을 사용해 미국의 CDN서버에 복사하여 미국에 있는 사용자 요청을 미국 CDN에 연결하면 비용과 속도 보장 가능

[https://learn.microsoft.com/ko-kr/azure/cdn/cdn-overview](https://learn.microsoft.com/ko-kr/azure/cdn/cdn-overview)

[https://brownbears.tistory.com/408](https://brownbears.tistory.com/408)

### GSLB → 로드 밸런싱 → CDN

- GSLB → 로드밸런싱 (서버가 죽은걸 찾아내는것)
- CDN → 서버가 죽은걸 찾아냈으면 주변에 다른 서버들을 찾아서 뿌리는 역할