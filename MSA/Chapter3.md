# 3장: 마이크로서비스 아키텍쳐의 기본

## 3-1. 서비스구조

### 서비스

 도메인의 해결 및 구현을 위해 활용하는 소프트웨어 컴포넌트 , 특정영역의 문제를 해결하기 위한 비즈니스 로직과 모델을 포함한다. 이들을 호출하기 위한 인터페이스(API)를 클라이언트 제공

### 비즈니스 데이터

데이터베이스 

서비스가 비즈니스 데이터를 포함한다 → 특정 DB에 접근하려면 특정 서비스를 통해야 한다. 

불특정 다수의 애플리케이션에서 DB를 공유 → 마이크로서비스적 설계가 아님.

## 3-2. 레이어 아키텍쳐

특정 기준에 근거해서 여러 계층을 만들고, 그 계층구조를 따라서 소프트웨어 컴포넌트나 기능을 분류, 관리하는 접근법이 레이어 아키텍쳐.

**사용자 인터페이스 계층** : 사용자 인터페이스 구축, 렌더링, 요청/응답 전송

**애플리케이션 계층**: 애플리케이션 조율, 도메인 객체 접근, 트랜잭션 관리 

**도메인계층**: 도메인 상태와 동작(비즈니스 로직)을 구현하는 서비스 배치

**인프라계층**: 가장 아래에 있음. 외부 리소스가 다른 계층에 접근할 수 있도록 지원. 데이터베이스나 메시징 같은 외부 시스템과 연동할 때 사용

**✅ 파사드 디자인 패턴**

: 일련의 저수준 인터페이스들을 하나의 고수준 인터페이스들로 묶어주는 패턴

저수준 인터페이스의 동작을 제어하려면 여러 저수준 인터페이스 메서드들을 일일이 호출해야하는데 파사드 패턴을 이용하면 고수준 인터페이스 호출만으로 한번에 할 수 있다.

[https://kotlinworld.com/372](https://kotlinworld.com/372)

### ⚒️ 레이어 아키텍쳐의 장단점

장점: 간단하면서 이해하기 쉽다. 기능 분할이나 구조화를 진행하기 쉬워서 소프트웨어 컴포넌트를 조합해서 개발하는 방식에 적합

단점: 확장성이 약하다.  추상적인 것이 구체적인 것에 의존하기 때문!

소프트웨어 컴포넌트가 인프라 구현에 의존하고 있다. 

(확장성: 레이어 아키텍쳐 프로그램은 그대로 유지하고 프로그램은 인프라만 변환한다는 것)

### 📶 해결책: 제어반전

제어반전이란 특정 소프트웨어 컴포넌트와 그 컴포넌트를 의존하는 측의 의존관계를 역으로 반전시키는 것.

스프링에서는 DI를 통해 제어반전을 구현. IoC를 도입한 것이 헥사거널 아키텍쳐

## 3-3. 헥사거널 아키텍쳐

![Untitled](Images/ch3-1.png)
불특정한 데이터 입출력에 대응할 수 있도록 확장성을 가진 것이 특징.

도메인(비즈니스 로직)을 중심으로 함. 주변에는 도메인을 호출하는 입력 측과 도메인에 의해 실행되는 출력측이 있음.

### ✅ 포트와 어댑터

어댑터: 외부 기능과 상호작용하는 역할을 하며, 외부 기능 단위로 교체 가능. 

포트:추상화된 프로그래밍 인터페이스를 도메인에 제공하는 것.

포트&어댑터 구조: 외부기능에 의존하지 않는 비즈니스 로직 설계 및 구현 , 외부 기능 쉽게 교체할 수 있어서 확장성 챙기기도 가능.

![Untitled](Images/ch3-2.png)

**컨트롤러**가 **인바운드 어댑터**

**서비스**에 접근할 때는 **포트**

인터페이스 계층과 인프라 계층에서 사용하는 드라이버들이 헥사거널의 포트와 어댑터에 배치됨.

애플리케이션 서비스, 도메인 서비스, 인프라 서비스 일부가 헥사거널 중심 육각형에 위치함.

## 3.4. 데이터베이스 접근

모델 == 비즈니스 데이터

마이크로서비스에서는 자신이 포함하지 않은 모델에 접근할 때는 해당 모델이 속한 서비스를 거쳐서 데이터에 접근. **여러 서비스가 하나의 데이터베이스 공유 X** 

why? 데이터베이스 변경에 대한 배려 때문!

공유 데이터베이스 모델을 취하고 있다면 여러 프로그램을 변경해야 해서 오히려 유연하고 신속한 데이터베이스 변경에 방해가 됨 

![Untitled](Images/ch3-3.png)
## 3.5. 트랜잭션 처리

### 로컬 트랜잭션

- 마이크로서비스에서는 로컬 트랜잭션을 추천함.
- 로컬 트랜잭션이란 하나의 트랜잭션 컨텍스트 내에 처리 대상 리소스를 제한하는 것.

💚 **예시**

1. begin과  commit으로 구분된 범위에 **하나의 데이터베이스**만을 처리대상으로 한다는 것,
2. 서비스가 하나의 DB를 포함하고 트랜잭션 컨텍스트 내에서 해당 DB만 대상으로 처리하는 경우

### 글로벌 트랜잭션

- 하나의 트랜잭션 컨텍스트 안에서 **여러 리소스 처리**하는 것
- **분산 트랜잭션 구조** 사용하여 구현
- ‘동시에’ 해야하는 경우에 사용
- 마이크로 서비스에서는 그닥 추천하지 않음 (컴포넌트의 느슨한 결합을 방해할 수 있기 때문)

## 3.6. 데이터베이스 간 동기화

기존보다 작은 단위로 여러 데이터베이스를 운영해야하는데 이런 데이터베이스들을 동기화하려면 어떻게 해야할까?

### 사가

- 데이터베이션 동기화를 위한 솔루션.
- 로컬 트랜잭션, 이벤트, 보상 트랜잭션 등의 기술 및 기법을 사용해서 여러 리소스간 동기화 취하는 디자인 패턴
- 최초 ****서비스**가 최초 **데이터베이스를 변경**하고, db 변경이 성공하면 메시징 구조를 사용해서 이벤트를 전달.
- 만약 장애가 발생해서 db 변경에 실패했다면? → 장애 발생 이전에 db에 적용한 내용을 되돌리는 로컬 트랜직션 실행 . 이것을 **보상 트랜잭션**이라고 함.
- 데이터베이스의 일관성 유지해야할때는 사가가 적합하지 않음

![Untitled](Images/ch3-4.png)

a가 b의 데이터 필요하면 b의 데이터에 요청하는게 아니라 b의 **서비스**에 요청해야함.

스키마가 안맞아서 에러가 뜰 수 있기 때문!

DB가 나누어져 있으니 물리적인 트랜잭션은 불가능함. Solution이 사가 트랜잭션!

실패하면 끝까지 롤백하는 이벤트+보상 트랜잭션 기법 사용

서로 메세지로 통신 (메세지 받는 순간 데이터 넣기 , 로직이 실패한다면 그 전에 또 알려줘야함 , 실패했으니 롤백 시켜라 —> 보상 트랜잭션)

## 3.7. 데이터 결합

여러 데이터베이스에 나누어져 있는 데이터를 하나의 뷰로 구성해서 클라이언트에 제공하려면?

1)  API 컴포지션

도메인계층의 집약 서비스와 인프라 계층의 리포지터리 서비스를 통해서 복수의 DB로 부터 얻은 데이터를 애플리케이션 계층에서 인메모리로 결합하는 디자인 패턴.

장점: 직감적이고, 간단하며 설계와 구현에 용이

단점: 운영환경의 메모리 내에서 결합하기 때문에 처리가 메모리에 집중됨 → 시스템 리소스에 큰 부담을 주어 성능및 확장성에 큰 영향

2) CQRS와 이벤트 소싱

- 데이터 결합의 해결책 , 결과 일관성을 구현하는 새로운 데이터 접근 패턴

### CQRS

데이터 접근처리를 갱신형 처리(명령, 데이터 삽입/변경/삭제) 와 참조형 처리(질의, 데이터 검색/취득)으로 구분하고, 각각을 구현하기 위해 독립된 서비스 컴포넌트와 데이터 저장소를 두는 디자인 패턴

갱신형 처리의 목표 : 요청량이 적기에 안전하고 확실한 트랜잭션 요구

참조형 처리의 목표 : 요청량이 많기에 빠른 응답 필요로

⇒ 갱신형 처리용과 참조형 처리용으로 분리된 프로그램과 데이터 저장소를 사용하자는 발상이 CQRS!

### 이벤트 소싱

갱신형 저장소와 참조형 저장소를 동기화 해주는 구조가 이벤트 소싱

비즈니스 데이터와 친한 데이터 처리 모델

비즈니스 데이터를 분할하지 않고 그대로 모아서 하나의 데이터 저장소에 저장. 이 데이터 저장소를 이벤트 소스라고 함. 

이벤트 소싱이 이력을 저장,보관하기엔 좋지만 빠른 검색에는 적합하지 않음

필요에 따라 검색용 데이터 스토어를 준비하고 메시징 기반 미들웨어의 비동기 메시징을 이용해 이벤트 소스와 검색용 데이터 저장소 동기화 

### CQRS와 이벤트 소싱의 장단점

장점: 쿼리 구현의 용이성, 데이터 감시, 접근 제어 구현의 용이성, 서비스 모델링과 친화성이 높음

단점: 기존 설계방식과 다른 난해함

## 3.8. 서비스 간 연계

서비스간 통신프로토콜로 자주사용되는 것이 REST와 메시징

### REST

클라이언트가 요청을 전송한 후 그에 대한 응답을 기다리는 동기형 프로토콜

### 메시징

단순한 처리는 물론이고 복잡하고 무거운 처리패턴까지 고려하면 서비스 간 연계기법인 메시징을 사용하는 것이 좋음. MOM을 통해서 생산자,소비자가 메시지를 주고 받는 통신 모델

## 3.9. 서비스화 진행방법

### 세션정보 유지

세션 영구화 : 처리 중인 상태를 데이터베이스등의 영구적 데이터 저장소에 저장해 두는 기능

스티키 세션: 처리상태가 저장돼 있는 서버(프로세스나 컨테이너)에 클라이언트 요청을 전송하는 것 

⇒ 부하분산 장치나 웹 애플리케이션 서버등이 가지고 있는 기능, 클라우드 네이티브 컴퓨팅 제품들도 제공. (쿠버네티스!)

마이크로 서비스에서 세션정보를 유지하려면 상태의 서비스화 기법을 사용하는 것도 추천!

상태를 유지하기 위한 서비스 신설하고, 스테이트 자체는 DB등의 영구저장소에 저장. 최종 사용자의 요청과 상태는 사용자 ID로 연결 

마이그레이션 기간 중의 의존관계

기존 모노리스가 신규 릴리스할 서비스에 의존 → ✔️

신규서비스가 기존 모노리스에 의존 → ❌

WHY? 가까운 미래에 기존 모노리스를 변경하는 경우 더 큰 영향을 미쳐서 마이크로서비스의 서비스화에 영향 미침 



# 📌질문

- **마이크로서비스에서는 하나의 서비스가 오직 하나의 데이터베이스를 가지는 것인가요? 여러개의 db를 가질 수는 없나요?**

-> 여러개 디비를 가지는가에 따라 다름 (cqrs)

→ 도메인을 잘못설계했다고 볼 수 있음

→ 보통 디비 안에 또 다른 디비를 넣는 경우가 있어도 물리적으로 두개 가지는 경우는 크지않음

- **MOM은 어떤 역할을 하나요?**
    - 미들웨어의 서버를 브로커라고 함
    - 역할: 서비스에서 이벤트가 발생하면 그 이벤트를 메세지한테 던져줌
        - a에서 B라는 서비스의 정보를 얻고 싶으면 서로 직접적으로 연결되는게 아니라
        - A에서 메세지로 던지고 메세지가 B에 전달해줌 (A와 B는 서로 모름)  
    - MOM은 AMQP로 연결
       -  인스턴스가 데이터를 서로 교환할 때 사용하는 방법
        MQ를 오픈 소스에 기반한 표준 프로토콜이 AMQP(Advanced Message Queuing Protocol)이다.
        AMQP 자체가 프로토콜을 의미하기 때문에 이 프로토콜을 구현한 MQ제품들은 여러가지가 있으며 그 중 하나가 RabbitMQ이다.

- **ddd에서 도메인 중심으로 한다는게 뭘까요?**
    - 쇼핑을 중심으로 도메인 설계를 하는거지, 머 MySQL을 쓴다던지 하면 안됨 (기술적인 걸 얘기하면안됨)
    - ddd에서는 언어가 중요함! (똑같은 용어에 대해서 서로 가지는 의미가 다름 → 똑같은 용어로 얘기를 한다 → 유비쿼터스)  

- **레이어 아키텍쳐에서 애플리케이션 조율이 어떻게 이루어지는건지?**
    - 마이크로서비스는 서비스를 쪼개서 rest방식으로 통신하는 방식
    - 게이트웨이가 없다면 여러 서비스를 경유해야함
    - API게이트웨이가 계층을 하나로 묶는다(파사드)

- **헥사거널의 포트는 어떤 부분에 해당하나요?**
    - 포트는 추상화되어 있어야 (인터페이스)
    - 인바운드면 포트가 서비스
    - 아웃바운드면 포트가 리포지토리 인터페이스

- **메시징이 뭘까요?**
    - Client와 동기방식으로 많은 데이터 통신을 하게 되면 병목현상이 생기게되고, 서버의 성능이 저하됨 -> 이런 현상을 막고자하여 또 하나의 미들웨어에 메시지를 위임하여 순차적으로 처리를 하는 것 
    - 메시징 기반으로 마이크로서비스를 짜면 EDA라고 함
    - 서비스하나 띄우는거라 생각하면 됨
    - 메세징 서비스로는 rabbitmq (spring)가 있음!
    - [https://jsonobject.tistory.com/560](https://jsonobject.tistory.com/560)
    - amqp를 이용해 비동기 통신
         - 메시징 안쓰면 a가 b에게 정보 받아오려면 b의 스펙을 다 알아야함
        - 만약 b의 프로토콜이 바뀐다면???!
        - 서로 추상화 해야하고 그 사이에 뭔가가 있어야 하는데 그게 MOM
    - 메세징의 가장 큰 장점은 비동기!
        - 주문만 했을 뿐인데 상품 서비스까지 호출해야한다.
        - 처리가 됐다는 이벤트를 메세지한테 보내주면 사용자는 할 일 끝. 서비스 호출까지 기다릴 필요가 없다!
    - RabbitMQ말고도 KAFKA(Apache) 도 있음

# 📚 스터디 내용 정리

## 레이어드 아키텍쳐

![Untitled](https://user-images.githubusercontent.com/85864699/201509606-b348d35c-7c84-46ec-b127-96a5654eabf6.png)

- MVC 패턴은 대표적 레이어드 아키텍쳐 중 하나
- 변경의 영향도를 근접 레이어에만 가게 하겠다.
    - Controller → API요청받고 렌더링 하는 역할
    - view→ 렌더링된 걸 view로 보여줌
    - Model → 뒷단이 전부다 model이 아님! service 거치고 나서 받은 dto를 model이라고 함
- MVC는 프레젠테이션 레이어에서 적용하는 아키텍쳐이다!
- db는 i/o작업만 해야하는데 비즈니스 로직을 디비에 놓으면 일을 더 많이하게 된다!
- service 는 pojo만 순수하게 작성 → 디비 변경에 굉장히 유리함

## 헥사고날 아키텍쳐

[외부영역]

- 기술적인 애들 → 어댑터 쪽 (받는건 REST API로 받고, 어떤 포트로 받겠다)
- 인프라
- 인바운드와 어댑터 포트는 인터페이스로만 되어 있음
- 아웃바운드 포트도 디비에 대한걸 아는게 아니라 인터페이스로
- “추상계층 하나 놓으면 다 해결할 수 있다” 라는말과 일맥상통

[내부영역]

- 순수 pojo → service (잘 안바뀌는 부분)
- 도메인 / 서비스
- 주문 서비스에 대한거

MSA로 바뀌는 이유 → 비즈니스 민첩성

## CQRS와 이벤트 소싱

- CQRS :  “따로 두자”

    - 갱신형 (C,U,D)

    - 참조형(R)

    -  CUD(쓰기)와 R(읽기)의 책임을 분리하는데 착안한 방식으로 아키텍처 패턴이 아닌 코드 패턴

    - 갱신형과 참조형 동시에 가능함!

    - 데이터 베이스를 따로 씀 (Read에만 특화된거/ Create,Update,Delete에만 특화된거) → 이렇게 하면 디비를 특화된거에 따라 선택가능

- 이벤트 소싱
    - 모아둔거
    - 갱신형 저장소와 참조형 저장소 동기화
    - 주문이 오면 데이터 자체를 쪼갤 필요 없이 냅두기. 주문이라는 이벤트가 들어오면 쪼개서 저장하는게 아니라 **그냥 넣는거**
    - **사용자 행동을 그대로 저장**
    - 디비는 최종 행동만 저장하는데 (막 JOIN해서) 얘는 행동저장
    - 그럼 SELECT 안하냐?
        
        → 생성자 만들어서 반복문 돌려서 선택
        
        → **스냅샷**을 찍어두면 이벤트들을 재생 가능 (상태추적)
        
    - 이벤트 소스 담는 디비, 현재 상태하는 디비 따로 두기
    - 이벤트 소싱은 → 데이터 쌓는 용 CQRS는 →조회용 (NoSQL)

- CQRS와 이벤트 소싱 같이 사용
    
    [장점]
    
    - MSA 적용시 글로벌 트랜잭션 피할 수 있음
    - 사용자는 주문만 했을 뿐인데 거기에 연결된 많은 서비스들이 다 호출 (이게 글로벌 트랜잭션)
    - 기능에 최적화된 구현(조회용 참조형)

[단점]

- 엄격한 트랜잭션이 필요한 비즈니스의 경우 사용이 어려움
- 만들아야 하는 컴포넌트 증가 (이벤트 메시징 컴포넌트 등등)

##  MSA에서 인증과 인가

이 서비스 갈때도 인증과 인가 해야하나? 저 서비스 갈때도 인증과 인가해야하나

→ 그렇게 하지 말자

→ 서비스는 내부 네트워크 사용하기에 굳이 검사할 필요 없다

- API 게이트 웨이를 만듦
- API 게이트웨이에서는 인증인가 하고 거길 넘어서 서비스 단에서는 인증과 인가 하지 않음