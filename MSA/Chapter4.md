

# 4장: 마이크로서비스 패턴

## 4.1. 마이크로 서비스 패턴

경험에서 만들어진 설계를 범용화하고 비슷한 과제에서 적용할 수 있게 한 것이 디자인 패턴

## 4.2. 데이터 관리 패턴

### 4.2.1. 데이터 관리 패턴 동기

- 분산 데이터베이스 권장
    - 서비스와 데이터 베이스가 일대일
- 리포지토리 이외 서비스는 리포지터리 경유해서 디비에 접속
    - 왜 분산 디비 권유? -> 약한 결합
    - 서비스와 디비 각각 약한 결합 -> 유연성
- 데이터 관리에서 고민해야하는 과제는 데이터베이스 배치 모델!
    - [과제1] 어떤 경우에 분산 데이터베이스화 할 수 없는것인지 그때 요구되는게 뭔지, 장단점 이해
    - [과제2] 분산 배치된 디비 간에 데이터 동기화 기법을 명확히 해두어야 함.
        - 글로벌 트랜잭션이 안되는데 어떻게 동기화하지?
    - [데이터3] 데이터 집약하는 법(데이터 결합)
        - 마이크로서비스는 데이터베이스가 분산 배치 되어 있음
        - 리포지터리를 통해 데이터베이스에 접속하기에 SQL사용 불가

### 4.2.2.  데이터베이스 배치 패턴의 예

**서비스별 데이터베이스 패턴**

- 약한결합을 통해 서비스 신속하고 유연하게 유지보수
    - 그래서 데이터와 베이스와 서비스 일대일로 놓는거 -> 변경요청이 있더라도 리포지터리 서비스 하나만 변경
- 데이터베이스 인스턴스가 서비스 단위로 작성 및 운영됨
- 장점
    - 유연하고 빠른 애플리케이션 변경
    - 요건에 맞는 최적의 디비 선택
- 고려사항
    - 결과 일관성
        - 분산 트랜잭션을 권장하지 않기에 여러 데이터베이스에 걸쳐 있는 데이터는 결과 일관성에 기반하여 동기화 됨.
        - 여러 데이터베이스간 데이터 동기화 구조 준비해야
            
            → 사가패턴 이용
            
        - 여러 디비에 걸쳐 있는 데이터 검색하는 구조 필요함
            
            → API 컴포지션, CQRS, 이벤트 소싱
            

**공유 데이터베이스**

- 공유데이터베이스를 쓰는 경우
    - 서비스별 데이터베이스 패턴에서 결과 일관성이 허용되지 않는 경우 , 데이터 일관성 확보하기 위해 데이터 분산화 포기해야함
        - 분산 트랜잭션 쓰지 않기 때문
    - 기존 데이터베이스 이용해야하는 경우
- 통합된 하나의 데이터베이스 인스턴스를 복수의 서비스 및 애플리케이션, 시스템이 공유할 수 있는 데이터베이스 배치 패턴
- 장점
    - 각종 서비스나 모노리스가 디비에 직접 접속
    - 업무 수행에 필요한 모든 데이터가 단일 데이터베이스 아래에 저장
    - 복수의 데이터 갱신 처리 시 로컬 트랜잭션 사용 → ACID 특성 유지, 데이터 일관성 확보
    - 익숙한 SQL사용 → 효율성 높일 수 있음
    - 기존 시스템과 데이터베이스 공동이용이 용이
- 단점
    - 불특정다수의 서비스나 애플리케이션이 데이터베이스를 공유하기에 디비 설계 변경에 큰 영향
    - 데이터베이스 변경 시에 비관적 락을 건후 변경 처리해야
    - 데이터 양이 증가한 경우 데이터베이스 서버를 스케일업 해야
        - 스케일 업이란 서버의 사양을 높여서 성능을 향상시키는 것
            - 메모리 증가, CPU 변경

### 4.2.3.데이터베이스 동기화 패턴의 예

**사가패턴 권장** 

- 로컬 트랜잭션+ 보상 트랜잭션+이벤트
- 사가는 분산 데에터 베이스 동기화 위한 디자인 패턴
- 로컬 트랜잭션 서로 연결하여 디비 동기화 장애발생시 이벤트 통해 보상 트랜잭션 연결해 데이터 처리 취소함
- 사가구현 → 코레오그라피, 오케스트레이션

cf) 보상 트랜잭션

- commit 한 데이터나 이미 반영한 데이터를 보정하는 트랜잭션

**코레오그라피**

- 디비에 접속하는 서비스가 각각 메시징 제품 통해 데이터 동기화
- 서비스 내부에는 비즈니스 로직이나 보상트랜잭션 로직에 추가로 사가를 성립시키기 위한 제어로직도 구현해야함
- 서비스가 능동적, 자립적으로 사가 프로세스를 돌리는 것을 코레오그라피 라고함
- 장점
    - 간단한 구조
    - 메세징 제품 준비해서 서비스 개발하면 코레오 그래피 스타일의 사가가 구현되는 것
- 단점
    - 사가 전체 흐름 파악 어려움
    - 서비스와 데이터베이스 간 연계 한눈에 파악 어려움
    - 트랜잭션 실행 시 진행상태 확인 어려움
    - 비즈니스 로직 구현해야할 서비스 안에 사가 제어로직이 함께 하므로 관심사 분리 저해됨

**오케스트레이션**

- 사가 오케스트레이터라 하는 특별한 서비스가 트랜잭션 처리를 조율
    - 애플리케이션 계층에 배치되는 애플리케이션 서비스로 구현
- 요청/응답 형식의 비동기 메세지 통해 비즈니스 로직 담당하는 도메인 계층 서비스에세 데이터 처리 요청
- 장애시에는 사가 오케스트레이터가 오류 감지해서 각 서비스에 보상 트랜잭션 실행 의뢰
- 장점
    - 각 서비스의 역할분담이 명확
        - 오케스트레이션에서는 **사가 오케스트레이터가 사가 제어 로직 담당**,
        - 도메인 계층 서비스 (데이터베이스에 접속하는 서비스)는 **비즈니스 로직과 데이터 처리에게 위임**하기에 역할 명확히 분리 가능 → 팀 개발 효율성
    - 서비스 간 흐름제어는 사가 오케스트레이션 내에 구현되어 있어서 **서비스와 데이터베이스간 연계 흐름 파악 쉬움**
- 고려사항
    - 사가 오케스트레이터가 무거워지지 않도록 역할분담에 유의해야한다
    - 원칙적으로는 오케스트레이션 선택 but 소규모 도메인 같은 국시적 일시적 구현은 코레오 그라피도 ㄱㅊ

**공통점**

- 둘 다 서비스간 연계에 메세징 제품 사용해야
- 서비스에서는 데이터베이스 접속과 메세지 전송을 하나의 트랜잭션 내에서 끝내야
→ 기존에는 이걸 분산트랜잭션으로 해결할 수 있으나 msa에서는 권장하지 않음
- 서비스 내의 데이터 베이스와 메시징 간 일관성 어떻게 해결할 수 있을까?
: 트랜잭셔널 메시징

## 4.3.트랜잭셔널 메시징 패턴

사가에서  무조건 동기화해야하는 것 → **데이터 처리, 이벤트 처리** 

사가에서는 데이터베이스 처리를 적용함과 동시에 해당 처리가 완료되었다는 것을 이벤트를 통해 통지

트랜잭션 방식

- 데이터베이스와 이벤트 경유하는 MOM 대상으로 글로벌 트랜잭션(마이크로서비스에서는 안함)
- 사가구현에 데이터베이스 처리와 이벤트 동기화하려면 **데이터 베이스 처리와 완벽하게 동기화하는 이벤트 처리(메세징)** , 즉 **트랜잭셔널 메세징이 필요함**

### 4.3.1.트랜잭셔널 메세징 패턴

### 트랜잭셔널 아웃박스

- 트랜잭셔널 메시징을 구성하는 패턴중 하나.
- 실체는 **데이터베이스 테이블**
- 비즈니스 데이터 저장하는 데이터베이스 내에 함께 존재.
- 비즈니스 데이터 처리를 통지하는 이벤트 정보를 저장 및 공유할 때 사용
- 비즈니스 데이터와 트랜잭셔널 아웃박스는 동일 db에 공존하기에 로컬 트랜잭션으로 바로 동기화 가능
- 아웃박스: 이메일의 발송함/ db의 처리 통지하는 이벤트의 발신자 라는 명칭
- 오류 발생시 오류난 테이블 처리 롤백 → 아웃박스 테이블→ 메세지 릴레이→ 메세지 브로커 →서비스 처리 실패 이벤트 통지
- 트랜잭셔널 아웃박스 내에서 **메시지 취득 방법**에 따라 폴링 퍼블리셔, 트랜잭션 로그 테일링으로 디자인이 나뉨. (모두 사가 패턴의 로컬 트랜잭션 내부 디자인)

### 폴링 퍼블리셔

**[특징]**

- 아웃박스 테이블 읽는 메세지 릴레이가 아웃박스 테이블을 정기적으로 참조 (polling)하는 디자인
- 아웃박스 테이블이 RDB라면 메세지 릴레이는 JDBC나 ODBC 통해 구현

**[장점]**

- 애플리케이션으로 구현하기 쉽다

**[단점]**

- 아웃박스 테이블에 의존하기 때문에 유지/관리와 개발및 운영비용 산정해야

### 트랜잭션 로그 테일링

![Untitled](https://user-images.githubusercontent.com/85864699/202061230-5905257c-2ca5-425e-b0cd-52378019edd6.png)

**[특징]**

- 트랜잭셔널 메시징의 시작점으로 DBMS가 가지고 있는 트랜잭션 로그의 로그 엔트리 활용하는 패턴
- 로컬 트랜잭션 활용하여 업무 테이블 갱신 + 처리 내용을 DBMS가 관리하는 로그에 기록
- 로그 마이너 : 메세지 릴레이
- 로그 마이너 이용하여 DBMS 트랜잭션 로그 상에 기록된 로그 엔트리 취득

[장점]

- DBMS가 제공하는 트랜잭션 로그를 사용하기에 아웃박스 테이블의 유지/관리에 수고를 들일 필요가 없다.

[단점]

- 트랜잭션 로그의 사양이 db의 종류마다 다르기 때문에 제품 단위로 트랜잭션 로그 마이너 구현해야 → 유지/보수에 부담

## 4.4. 서비스 검색 패턴

### 4.4.1. 문제정의

- 서비스 배포 시마다 도메인명과 IP주소가 변경될 가능성 있음. →정확한 위치 파악해야
- 서비스 검색: 도메인 명을 가지고 IP주소 알아내는 DNS와 유사

### 4.4.2. 검색패턴 예시

**1) 클라이언트 측 검색**

- 클라이언트가 서비스의 위치 주소 파악

**2) 서버 측 검색**

- 서비스 위치 주소 파악을 서버 측 컴포넌트(라우터)에 위임
- 클라이언트가 라우터에 서비스 호출 요청 → 서비스 레지스트리와 연계해서 서비스 위치 찾음 → 해당 서비스로 클라이언트 요청 전송

### 4.4.3. 서비스 레지스트리 패턴

- 마이크로서비스에서 서비스명 해석하는 컴포넌트
- 서비스명 해석하는 영구데이터 저장소

### 4.4.4. 서비스 레지스트리 등록 패턴 예시

- 등록 주체에 따라 구별

**자가 등록**

- 자신의 도메인명과 주소 정보를 매핑해서 위치 정보 구성 → 서비스 레지스트리에 등록

**외부자 등록**

- 서비스 레지스트리의 위치 정보 등록을 애플리케이션 프로그램 외에 제 3자에게 위임하는 디자인 패턴.
- 예시 :  쿠버네티스
- 외부자 등록을 활용하면 위치정보 관련 작업 줄일 수 있음.

## 4.5. 외부 API 패턴

- 마이크로서비스: 하나의 애플리케이션이 여러 개의 서비스로 구성
- 온라인 쇼핑에서 하나의 상품 발주 : 여러개의 서비스 호출

### 4.5.1. 해결해야할 문제점

1. 통신 프로토콜 교환 및 교차
- 인터넷과 인트라넷 간 통신 프로토콜 해결
    
    cf) 인터넷 vs 인트라넷
    
    인트라넷: 인트라넷은 인터넷 기술을 이용하여 내부업무를 통합하는 정보시스템, 별도의 통신망이 아닌 인터넷을 이용하여 조직 내부시스템을 구축하는 것
    
    인터넷:통신망과 통신망들이 연결 되어 있는 망들의 집합
    
    - 클라이언트와 서비스가 통신할때는 주요 프로토콜인 HTTPS 기반의 REST나 웹소켓 사용하고, 인트라넷에서는 메시징 사용
    
1. 네트워크 지연
    - 인터넷은 비교적 속도가 느린 네트워크
    - 클라이언트와 서비스 간 통신횟수 최소화해야
    
2. 클라이언트 프로그램 코드
- 네트워크 프로그래밍은 네트워크 접속 열기 및 닫기, 비정상인 경우 예외처리 해야해서 코드 양이 많이 증가.
- 애초에 서비스 호출 횟수 자체를 줄이자!
- 클라이언트가 여러 서비스에 접근하면 각 서비스의 변경이 클라이언트 프로그램의 변경에도 영향을 줌. → 서비스 변경이 클라이언트 프로그램에 영향을 주지 않도록 장치를 마련해둬야함.
- 다양한 클라이언트 종류 지원하기 위한 구조도 고려해야함 ( 통신방식, 요청과 응답 형식, 응답내용)

### 4.5.2. 외부 API 패턴의 예

마이크로서비스에서 클라이언트와 서비스 연동시에 발생하는 문제점을 해결하기 위해  API 게이트웨이 패턴, 프론트엔드용 백엔드 패턴을 둠.

### API 게이트웨이 패턴

- **클라이언트 처리 담당**하는 전용 서비스(API 게이트웨이) 배치
- ‘주문’이라는 목적에 대해서 주문용 API게이트 웨이를 만드는 것
- 클라이언트와 서비스 간에 목적 단위로 API 게이트웨이 배치해서 애플리케이션 조율, 트랜잭션 처리 구현

### 프론트엔드용 백엔드

- 불특정  다수의 클라이언트가 하나의 API 게이트웨이 공유하는 경우, 오류 발생을 최소화하는 외부 API패턴
- 요청이나 응답 렌더링, 통신 프로토콜 교환을 담당하는 소프트웨어 컴포넌트.
- 서버 측에서 클라이언트에 맞닿아 있는 곳에 배치
- API 게이트웨이 와의 차이점
    - 설치 단위 : 클라이언트별로 BFF 배치 , 브라우저 별로 배치
    - 4.5.1 에서의 다양한 클라이언트 종류 지원 문제  해결가능
- API 게이트웨이와 클라이언트 고유의 게이트웨이 기능 분할 가능

RECAP

- API게이트웨이 제품은 인증 및 허가,로그,메트릭스,부하분산 등 범용적인 관리용도로 사용
- API 게이트웨이는 **애플리케이션 조율** 책임짐
- 프론트엔드 용 백엔드 패턴은 **클라이언트별로 게이트워이 처리 적용**

## 4.6. 통신패턴

- REST는 요청/응답 및 동기형 통신에 문제가 있음

- 비동기형 통신상태가 필요할 수도 있음
- 운영 실수나 장애에 대비하여 멱등성도 있어야 함(실행 횟수에 상관없이 결과가 같다는 것을 보장하는 특성)

4.6.1. 통신패턴 예

1) 원격 프로시저 호출(RPI)

- 대표적 예시 REST
- [장점] 쉽고 범용적
- [단점] 복잡하고 시간이 오래걸리는 작업에는 적합하지 않음

2) 메시징

- 비동기적 통신 형태
- 발행자,구독자가 이벤트(메시지)를 통해 통신하는 모델
- MOM 또는 메세지 브로커를 통해 이벤트나 메시지 비동기적 전달
- 이벤트(메세지)는 MOM 토픽(큐)에 저장돼있으므로 구독자는 원할 때 이벤트(메세지) 가져올 수 있음
- 같은 마이크로서비스 패턴인 사가나 CQRS등에 사용

3) 도메인 특화 프로토콜

- 특정 상황에 맞는 고유의 프로토콜을 적용하는 디자인
- 메일 발신: SMTP , 메일 수신 : POP,IMAP

4) 멱등 소비자

- 멱등: 실행 횟수와 상관없이 결과가 같다는 것을 보장하는 특성
- 멱등소비자: 의도하지 않은 작업에도 멱등성을 보장
- 사가와 트랜잭셔널 아웃박스 패턴

## 4.7.배포패턴

- 배포는 프로세스와 아키텍쳐라는  상호 연관된 두개의 요소로 구성
- 프로세스: 개발팀과 운영팀이 실행하는 단계
- 아키텍쳐: 소프트웨어가 실행되는 환경의 구조 정의
- CI/CD 와 IaaS를 통한 배포

### 4.7.1. 배포패턴의 필요성

1. 분산 애플리케이션
    - 다양한 언어와 프레임워크로 구성된 분산 애플리케이션
    - 어떤 단위 로 플랫폼 또는 런타임으로 배포하는가에 따라 배포 아키텍쳐 설계가 달라짐
2. 확장성
    - 마이크로 서비스는 서비스 단위로 최적의 배포패턴을 설정 → 리소스의 가동률 최적화 & 확장성 확보 가능
3. 유지/보수
    - 마이크로 서비스는 여러 작은 서비스를 조합해서 시스템 구성 → 복잡
    - 통신 부하에 의한 성능 저하, 장애 발생 가능 지점의 증가
    - 운영 리소스 최적화 하려면 고도로 자동화된 배포 프로세스와 배포 아키텍쳐 필요
4. 최신기술 도입
    - CI/CD 도입

### 4.7.2. 배포패턴의 예

1. **호스트별 다중 서비스 인스턴스**
- 호스트 관리에 용이
- 인프라 운영비용 감소
- 하나의 가상머신에서 여러 서비스 실행하면 전체 리소스 줄이기 가능

1. **호스트별 단일 서비스 인스턴스**
- 한대의 호스트에 여러 서비스가 의존하는 문제 해결 → 장애 관리 효율
- 다른 서비스와 독립된 단위로 서비스 확장 가능
- 호스트 수 증가 == 비용 증가

1. **VM별 서비스 인스턴스**
- 배포 대상으로 하이퍼 바이저형 가상 머신 사용하는 패턴
- [단점]
    - 무겁고 배포에 시간이 오래 걸림
    - 컨테이너 보다 많은 리소스 사용
    - 시스템관리 비용 높음
        - OS,미들웨어, 언어 런타임 등 패치 적용/ 경우에 따라 가상머신 이미지 재 생성
- [장점]
    - 서비스가 적은 애플리케이션의 경우 적은 비용으로 간단한 배포 가능,
    - 서비스 인스턴스를 패키지화 & 분리 가능

1. **컨테이너별 서비스 인스턴스**
- 컨테이너라는 OS 수준의 가상화 기술을 사용해 서비스 인스턴스 구성하는 패턴
- [장점]
    - 배포속도가 빠르다.
        - OS 포함하지 않아서 가벼움
        - 가상머신은 내부 게스트 OS 실행에 시간 걸림/ 컨테이너는 OS 상의 프로세스 실행만 하면 됨
    - 리소스 효율이 높다.
    - 이동성이 좋다.
        - 호스트 OS의 커널을 공유하고, 애플리케이션 프로세스를 시스템의 다른부분과 분리해서 실행가능
- [단점]
    - 컨테이너 기반의 구축 및 운영이 쉽지 않다.

1. **서버리스 배포**
- HTTP 사용하는 웹앱이나 모바일 앱에서 이벤트나 호출을 받으면 서버리스 서비스를 사용해서 애플리케이션 로직을 실행하는 방식
- 개발자가 애플리케이션 로직 작성에 집중할 수 있게 클라우드가 자동확장,가용성 관리, 유지/보수등 알아서 관리해줌
- [장점]
    - 서버 리소스 의식 안함→ 서버 관리 및 운영 불필요
    - 서비스 부하에 따라 자동으로 확장
    - 서비스 요청량 기준으로 과금..!
- [단점]
    - 지연 발생
        - 애플리케이션 인스턴스를 프로비저닝(클라우드 상태에서 배포해서 실행가능한 상태로 만들어두는 것) 하므로 애플리케이션이 실행되기 까지 시간이 꽤 걸림
    - 이벤트/요청 기반의 프로그래밍 모델로 제한
        - 지연 시간 떄문에 이벤트/요청 기반의 서비스에서만 사용 가능\

## 4.8. 관찰 가능성 패턴

마이크로서비스에서는 감시 대상인 각 서비스나 관련 컴포넌트가 **논리적 또는 물리적으로 분산 배치**돼있음. 빠짐없이 확실하게 감시하기 위해서는 요구되는 것이 관찰가능성 패턴

### 4.8.1. 관찰 가능성 패턴의 예

**분산추적**

- 각 요청 또는 이벤트 단위로 **고유한 ID**를 할당하고 로그나 트레이스에 기록하므로 처리 상황이나 장애 원인을 추적하기 쉽게 만드는 기술

**로그 통합**

- 마이크로서비스 같은 분산 컴퓨팅 환경에서는 로그도 분산 출력됨.
- 로그가 흩어져서 서비스 호스팅 시 신속한 복구에 문제가 생기는데 로그통합을 통해 로그 분산에 의한 문제를 미연에 방지 가능
- 시스로그, 플루엔티드 등의 상용, 오픈소수 솔루션 이 예시

**예외 추적**

- 예외 관리해서 관리자에게 알리는 패턴

**애플리케이션 메트릭스**

- 분산 배치된 서비스를 적절하게 관리하려면 컨테이너 등 각 애플리케이션의 런타임 상태를 적시에 파악할 필요 있음
- CPU 사용률이나 메모리등 시스템 리소스 상태는 물론 **처리 요청 수나 응답 시간등의 메트릭**을 수집해서 감시하는 패턴
- 쿠버네티스 등 오케스트레이션 프레임워크는 애플리케이션 메트릭을 통해 수집한 정보를 바탕으로 확장을 관리

**감사 로그**

- 마이크로서비스의 사용자 활용통계와 분석을 목적으로 하는 패턴
- 사용자 활동 이력은 문제 발생 시 지원이나 문제 재현을 통한 분석등에 사용됨, 보안 방어 및 기업 규정 위반 확인등에 도움됨.

**상태확인 API**

- 각 서비스의 호출 가능 상태 파악하는 것
- 감시 주체인 컴포넌트가 각 서비스의 인스턴스에 폴링(polling)요청을 전송해 그 결과를 가지고 서비스 상태 파악
- 상태확인의 감시주체는 다양한 컴포넌트에 위임가능
    - 라우터나 부하분산 담당하는 컴포넌트가 상태확인하는 경우가 대부분
    - 서비스 레지스트리 처럼 서비스 위치 해결을 책임지는 컴포넌트가 감시할 수도

## 4.9. 리팩터링 패턴

- 개발이 끝난 시스템을 프로덕션 시스템으로 옮길 때 (마이그레이션 할 때) 필요한 것이 리팩터링 패턴
- 마이크로서비스가 모노리스에 의존하지 않게 해야함
- 서비스 릴리스는 작은 단위로 여러번 실시해야함.

### 4.9.1. 리팩터링 패턴의 예

**부패방지 계층**

- 서비스와 모노리스 연계 시에 발생하는 통신 프로토콜이나 애플리케이션 프로토콜의 차이를 해결하기 위한 마이크로서비스 패턴
- 서비스와 모노리스 사이에 프로토콜 차이를 해결하기 위한 **어댑터**를 설치하면 됨
- 예를 들어 모노리스가 SOAP 기반 RPC API를 제공하고 있다면 부패방지 계층의 어댑터를 통해
    - 서비스로부터 호출되는 인터페이스로서 REST API 구현
    - REST API 호출을 받아서 SOAP를 거쳐 모노리스 웹 API 호출하는 기능 구현
    - REST와 RPC 사이에 프로토콜 교환하는 로직 추가

**스트랭글러 애플리케이션** 

- 마이크로서비스가 모노리스를 하나씩 교체한다는 의미
- 클라우드 네이티브 애플리케이션으로 마이그레이션 할 때 도움이 됨
- 마이그레이션 작업은 PoC (사전검증)부터 시작됨.

![Untitled](https://user-images.githubusercontent.com/85864699/202061323-1e60a025-db0d-4f21-9c01-fc1c562aee9c.png)

- SoE는 고객 접점의 웹 어플리케이션 서브 시스템, SoR은 기반 시스템의 서브 시스템을 의미.
- PoC에서는 서브 시스템 일부를 마이크로서비스를 이용해 클라우드 네이티브화
- 동시에 SoE와 클라이언트의 경계인 스트랭글러 포드를 개발 및 배치
- 스트랭글러 포드란 일종의 포털 시스템.
    - 스트랭글러 포드가 제공하는 메뉴 화면에서 고객명을 클릭하여 특정 애플리케이션 이용하는 것.
- 각 단계의 마이그레이션 작업이 끝나면 에플리케이션으로 가는 요청이 마이크로서비스화 된 서비스로 라우팅 되도록 스트랭글러 포드의 메뉴 아이템이 가리키는 URI 변경
    - 마이그레이션 작업 후 바로 서비스를 릴리스해서 사용자가 서비스를 빠르게 접할 수 있음.

## 함께 보면 좋은 글

[https://www.lgcns.com/blog/cns-tech/36171/](https://www.lgcns.com/blog/cns-tech/36171/)

## 📌단어


💡 **이벤트 소싱**

: application의 모든 상태를 일으키는 이벤트를 순서에 맞게 저장하여 status를 만들어내는 방법

데이터의 상태를 변경시키는 모든 데이터를 저장 

object의 **모든 상태변화가 기록됨**

💡 **비관적 락과 낙관적 락**

: JPA는 데이터베이스 트랜잭션 격리수준을 READ COMMITTED정도로 가정 

일부 로직에 더 높은 격리 수준이 필요하다면 낙관적 락과 비관적 락 중에 하나 사용하면 됨

- **낙관적 락**
    - 트랜잭션 대부분은 충돌이 발생하지 않는다고 가정
    - 일단 충돌이 나는것을 막지 않고, 충돌이 난것을 감지하면 그때 처리
    - DB에서 제공하는 lock기능을 사용하는 것이 아닌 JPA가 제공하는 Version관리기능 사용
    - DB에서 락을 거는 것이 아닌 Application 단계에서 lock을 거는 것
    - 일반적으로 **version** 의 상태를 보고 충돌을 확인하며, 충돌이 확인된경우 롤백을 진행시킴.(hashcode나 timestamp를 이용해서 충돌을 확인할 수 도 있습니다.)
- **비관적 락**
    - 트랜잭션의 충돌이 발생한다는 것을 가정하고 먼저 lock을 거는 것 → 다른 트랜잭션이 접근하지 못하게
    - 데이터베이스에서 **Shared Lock(공유, 읽기 잠금)** 이나 **Exclusive Lock(배타, 쓰기 잠금)** 을 건다.
    - **Shared Lock** 의 경우, 다른 트랜잭션에서 **읽기**만 가능. 또한 **Exclusive lock** 적용이 불가능 (읽는동안 변경하는것을 막기 위해)
    - **Exclusive lock** 의 경우. 다른 트랜잭션에서 **읽기, 쓰기**가 둘다 **불가능**. 또한 **Shared, Exclusive Lock** 적용이 추가적으로 불가능 (쓰는동안 읽거나, 다른 쓰기가 오는것을 막기위해)
    - [장점]
        - **충돌이 자주 발생하는 환경**에 대해서는 롤백의 횟수를 줄일 수 있으므로 성능에서 유리
        - 데이터 무결성을 보장하는 수준이 매우 높음.
    - [단점]
        - 데이터 자체에 락을 걸어버리므로 **동시성이 떨어져** 성능 손해를 많이 보게 됨.특히 읽기가 많이 이루어지는 데이터베이스의 경우에는 손해가 더 두드러짐.
        - 서로 자원이 필요한 경우에, 락이 걸려있으므로 **데드락**이 일어날 가능성이 있음.
            
            cf) 데드락 : 운영체제 혹은, 또는, 그리고 소프트웨어의 잘못된 자원 관리로 인하여 둘 이상의 프로세스(심하면 운영체제 자체도 포함해서)가 함께 퍼지는 현상 → 교착상태를 의미
            

출처: [https://unluckyjung.github.io/db/2022/03/07/Optimistic-vs-Pessimistic-Lock/](https://unluckyjung.github.io/db/2022/03/07/Optimistic-vs-Pessimistic-Lock/)

💡 **스케일 업 & 스케일 아웃**

- 스케일 업
    - 기존 서버를 보다 높은 사양으로 업그레이드 하는 것을 말함.
    - 서버에 디스크를 추가하거나 CPU나 메모리 업그레이드 시키는 것
    - 하나의 서버로 능력 증강 → 수직 스케일링
- 스케일 아웃
    - 장비를 추가해서 확장하는 방식
    - 기존의 서버만으로 용량이나 성능의 한계에 도달 → 비슷한 사양의 서버를 추가로 연결해 처리할 수 있는 데이터 용량이 증가,기존 서버의 부하 분담해 성능 향상 효과 기대
    - 서버 추가 확장 → 수평 스케일링

출처:[https://tecoble.techcourse.co.kr/post/2021-10-12-scale-up-scale-out/](https://tecoble.techcourse.co.kr/post/2021-10-12-scale-up-scale-out/)

💡 **트랜잭션 ACID**

: 트랜잭션의 특징

- 원자성(Atomicity)
    - 트랜잭션 작업이 부분적으로 실행되거나 중단되지 않는 것 보장
    - All or Nothing의 개념
- 일관성(Consistency)
    - 트랜잭션이 성공적으로 완료되면 일관적인 DB 상태 유지하는 것 말함
    - 트랜잭션이 일어난 후 데이터 타입이 바뀌지 않는 것 등을 말함
- 격리성(lsolation)
    - 트랜잭션 수행 시 다른 트랜잭션 작업이 끼어들지 못하도록 보장하는 것
    - 트랜잭션끼리 서로 간섭할 수 없음
- 지속성(Durability)
    - 성공적으로 수행된 트랜잭션은 영원히 반영되는 것 말함
    - commit을 하면 현재 상태는 영원히 보장

💡 **JDBC ODBC**

- JDBC
    - JAVA에서 DB에 접근하여 데이터 조회,삽입,수정,삭제를 가능케 하는 것
    - JAVA가 데이터베이스 사용할 수 있도록 연결해주는 응용프로그램 인터페이스인 Java API
- ODBC
    - 데이터베이스를 엑세스하기 위한 표준 개방형 응용프로그램 인터페이스
    - 접속처의 데이터베이스가 어떤 DBMS에 의해 관리되고 있는지 의식할 필요가 없다. (JDBC는 JAVA와 연동되는 데이터만)

**💡 워커노드**

- 각기 다른 컨테이너들이 선적된 컨테이너 선의 역할
- 마스터 노드와의 차이점
    - 마스터 노드는 클러스터 관리하고 클러스터의 기능 실행
    - 워커 노드는 컨테이너화된 애플리케이션을 실행하는 시스템으로 서비스 실행, 모니터링 제공

## 질문

- 분산트랜잭션과 로컬 트랜잭션의 차이란 뭔가요?
- 서비스 레지스트리 등록을 할 때 외부자 등록이 어떤 면에서 서비스 위치 정보 관련작업을 줄일 수 있는건지?(85페이지)
- 컴포넌트가 각 서비스의 인스턴스에 폴링 요청을 보내서 상태를 서비스 상태를 파악한다고 했는데 폴링 요청이 정확히 어떤걸 하는건가요? (111페이지)
- 신규릴리스한 클라우드 애플리케이션에 장애가 발생했을때 스트랭글러 포드상의  URI를 기존 애플리케이션으로 변경하면 모노리스로 되돌릴 수 있다고 했는데 이러면 마이크로서비스 자체가 모노리스에 의존하게 되는거 아닌지?